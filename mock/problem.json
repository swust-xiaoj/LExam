{"total":356,"data":[{"acedNum":50,"author":null,"codeLimit":0,"createTime":"2016-04-09 20:58:53","description":"<p>尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。\n尼克的一个工作日为N分钟，从第一分钟开始到第N分钟结束。当尼克到达单位后他就开始干活。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第P分钟开始，持续时间为T分钟，则该任务将在第P+T－1分钟结束。\n写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。</p>","inputSample":"15\t6\n1\t2\n1\t6\n4\t11\n8\t5\n8\t1\n11\t5","inputTip":"输入数据第一行含一个空格隔开的整数N和K（1≤n≤10000，1≤k≤10000），N表示尼克的工作时间单位为分钟，K表示任务总数。\n接下来共有K行，每一行有两个用空格隔开的整数P和T，表示该任务从第P分钟开始，持续时间为T分钟，其中1≤P≤N,1≤P+T－1≤N。","judgeModel":0,"level":2,"limitMemory":65535,"limitTime":1000,"outputSample":"4","outputTip":"输出文件仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。","probId":17,"standardSource":"program p2;\nconst maxn=10000;\n\nvar k,i,j,n,m:longint;\n     f:array[1..maxn] of longint;\n     p,t:array[1..maxn] of longint;\n    time:array[1..maxn,1..2] of longint;\nbegin\n   readln(n,m);\n   for i:=1 to m do\n   begin\n    readln(p[i],t[i]);\n    if time[p[i],1]=0 then\n     begin\n      time[p[i],1]:=i;\n      time[p[i],2]:=i;\n     end\n    else\n     inc(time[p[i],2]);\n   end;\n  for i:=n downto 1 do\n  begin\n   if time[i,1]=0 then\n     f[i]:=f[i+1]+1\n    else\n    begin\n     k:=0;\n    for j:=time[i,1] to time[i,2] do\n     if f[i+t[j]]>k then\n      k:=f[i+t[j]];\n     f[i]:=k;\n    end;\n  end;\n  writeln(f[1]);\nend.","testdataNum":null,"title":"尼克的任务(修改)","totalSubmit":126},{"acedNum":0,"author":null,"codeLimit":0,"createTime":"2012-09-01 09:29:47","description":"这是一个很简单的排序题目.\r\n为了锻炼大家对不同算法的了解,请大家用归并排序法对此题进行解答.\r\n对一组整数数列A[1],A[2],A[3]......A[N]进行排序,按照从小到大的顺序输出.","inputSample":"12\r\n45 \r\n545 \r\n48 \r\n47 \r\n44 \r\n45 \r\n4857 \r\n58 \r\n57 \r\n485 \r\n1255 \r\n42","inputTip":"本题只有一组测试数据,在输入的第一行输入N(表示整数数列的大小)(N ＜ 1000)\r\n接下来N行输入N个整数,每一行一个整数.","judgeModel":0,"level":1,"limitMemory":65535,"limitTime":1000,"outputSample":"42  44  45  45  47  48  57  58  485  545\r\n1255  4857","outputTip":"对已经排好序的数从小到大依次输出,每两个数之间用两个空格隔开,且每输出10个数换行.","probId":20,"standardSource":"#include<stdio.h>\r\nvoid main()\r\n{\r\nint n,i,j,t,a[1000];\r\nscanf(\"%d\",&n);\r\nfor(i=0;i<n;i++)\r\n  scanf(\"%d\",&a[i]);\r\nfor(i=0;i<n-1;i++)\r\n  {for(j=i+1;j<n;j++)\r\n    if(a[i]>a[j]) {t=a[i];a[i]=a[j];a[j]=t;}\r\n  printf(\"%d  \",a[i]);\r\n  if(i>0&&(i+1)%10==0) printf(\"\\n\");\r\n  }\r\nprintf(\"%d\\n\",a[i]);\r\n}","testdataNum":null,"title":"合并排序","totalSubmit":0},{"acedNum":0,"author":null,"codeLimit":0,"createTime":"2012-09-01 09:31:39","description":"<p>There are n lockers in a hallway numbered sequentially from 1 to n. Initially, all the locker doors are closed. You make n passes by the lockers, each time starting with locker #1. On the ith pass, i = 1, 2, ..., n, you toggle the door of every ith locker: if the door is closed, you open it, if it is open, you close it. For example, after the first pass every door is open; on the second pass you only toggle the even-numbered lockers (#2, #4, ...) so that after the second pass the even doors are closed and the odd ones are opened; the third time through you close the door of locker #3 (opened from the first pass), open the door of locker #6 (closed from the second pass), and so on. After the last pass, which locker doors are open and which are closed? How many of them are open? Your task is write a program to output How many doors are open after the last pass? Assumptions all doors are closed at first.</p>","inputSample":"10","inputTip":"a positive numbers n, total doors. n<=100000","judgeModel":0,"level":1,"limitMemory":65535,"limitTime":1000,"outputSample":"3","outputTip":"a positive numbers ，the total of doors opened after the last pass.","probId":22,"standardSource":"#include<stdio.h>\r\n#include<cmath>\r\nint main(){int n;scanf(\"%d\",&n);printf(\"%d\\n\",int(sqrt(n)));return 0;}","testdataNum":null,"title":"Locker doors","totalSubmit":469},{"acedNum":0,"author":null,"codeLimit":0,"createTime":"2012-09-01 09:31:39","description":"　　在一个按照东西和南北方向划分成规整街区的城市里，n个居民点散乱地分布在不同的街区中。用x 坐标表示东西向，用y坐标表示南北向。各居民点的位置可以由坐标(x,y)表示。\r\n\r\n　　街区中任意2 点(x1,y1)和(x2,y2)之间的距离可以用数值|x1-x2|+|y1-y2|度量。\r\n\r\n　　居民们希望在城市中选择建立邮局的最佳位置，使n个居民点到邮局的距离总和最小。\r\n\r\n　　任务：给定n 个居民点的位置,编程计算n 个居民点到邮局的距离总和的最小值。","inputSample":"5\r\n1 2\r\n2 2\r\n1 3\r\n3 -2\r\n3 3","inputTip":"　　第1 行是居民点数n，1 < = n < =10000。接下来n 行是居民点的位置，每行2 个整数x 和y，-10000 < =x，y < =10000。","judgeModel":0,"level":1,"limitMemory":65535,"limitTime":1000,"outputSample":"10","outputTip":"n 个居民点到邮局的距离总和的最小值。","probId":25,"standardSource":"int main(){}","testdataNum":null,"title":"PostOffice","totalSubmit":492},{"acedNum":0,"author":null,"codeLimit":0,"createTime":"2012-09-01 09:33:55","description":"<p>\r\n\tThe problem is named after Flavius Josephus, a Jewish historian who participated in and chronicled the Jewish revolt of 66-70C.E. against the Romans. Josephus, as a general, managed to hold the fortress of Jotapata for 47days, but after the fall of the city he took refuge with 40 diehards in a nearby cave. There the rebels voted to perish rather than surrender. Josephus proposed that each man in turn should dispatch his neighbor, the order to be determined by casting lots. Josephus contrived to draw the last lot, and as one of the two surviving men in the cave, he prevailed upon his intended victim to surrender to the Romans.</p>\r\n<p>\r\n\tYour task:computint the position of the survivor when there are initially n people.</p>","inputSample":"6","inputTip":"a Positive Integer n is initially  people. n< = 50000","judgeModel":0,"level":0,"limitMemory":65535,"limitTime":1000,"outputSample":"5","outputTip":"the position of the survivor","probId":26,"standardSource":"#include <stdio.h>\r\n#include \"stdlib.h\"\r\nvoid main() \r\n{ \r\n\tint n,i,s=0;\r\n\tscanf(\"%d\", &n); \r\n\tfor (i=2; i<=n; i++) \r\n\t\ts=(s+2)%i; \r\n\tprintf (\"%d\\n\", s+1); \r\n}","testdataNum":null,"title":"The Josephus Problem","totalSubmit":258},{"acedNum":0,"author":null,"codeLimit":0,"createTime":"2012-09-01 09:33:55","description":"<p>\r\n\tA worst-case linear algorithm for the general case of selecting the kth largest element was published by Blum, Floyd, Pratt, Rivest, and Tarjan in their 1973 paper Time bounds for selection. The algorithm that it is based on was conceived by the inventor of quicksort, C.A.R. Hoare, and are known as Hoare&#39;s selection algorithm. In quicksort, there is a subprocedure called partition which can, in linear time, group the list into two parts, those less than a certain value (left), and those greater than or equal to a certain value (right, which ends up containing pivotValue). Your task: selecting the kth largest element in a list of n numbers. (n&lt; = 50000)</p>","inputSample":"9 5\r\n4 1 10 9 7 12 8 2 15","inputTip":"two lines \r\nthe first line have two numbers , the first numbers is total of list and  the second numbers is the kth largest element\r\nthe second line is a list of n numbers","judgeModel":0,"level":1,"limitMemory":65535,"limitTime":1000,"outputSample":"8","outputTip":"the kth largest element in a list of n numbers","probId":27,"standardSource":"#include <algorithm>\r\n#include <vector>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n\tint n,k;\r\n\t\r\n\tscanf(\"%d%d\",&n,&k);\r\n\tgetchar();\r\n\t\r\n\tint i,input;\r\n\tvector<int> num_list;\r\n\t\r\n\tfor (i=1;i<=n;++i)\r\n\t{\r\n\t\tscanf(\"%d\",&input);\r\n\t\tnum_list.push_back(input);\r\n\t}\r\n\r\n\tvector<int>::iterator pt;\r\n\r\n\tnth_element(num_list.begin(),num_list.begin()+k-1,num_list.end());\r\n\r\n\tprintf(\"%d\\n\",*(num_list.begin()+k-1));\r\n\r\n\treturn 0;\r\n}","testdataNum":null,"title":"Partition-based general selectio","totalSubmit":256},{"acedNum":0,"author":null,"codeLimit":0,"createTime":"2012-09-01 09:36:11","description":"<p>In numerical analysis, the Horner scheme or Horner algorithm, named after William George Horner, is an algorithm for the efficient evaluation of polynomials in monomial form. Horner&#39;s method describes a manual process by which one may approximate the roots of a polynomial equation. The Horner scheme can also be viewed as a fast algorithm for dividing a polynomial by a linear polynomial with Ruffini&#39;s rule.</p>\r\n\r\n<p><strong>Application</strong></p>\r\n\r\n<p>The Horner scheme is often used to convert between different positional numeral systems &mdash; in which case x is the base of the number system, and the ai coefficients are the digits of the base-x representation of a given number &mdash; and can also be used if x is a matrix, in which case the gain in computational efficiency is even greater.</p>\r\n\r\n<p><strong>History</strong></p>\r\n\r\n<p>Even though the algorithm is named after William George Horner, who described it in 1819, the method was already known to Isaac Newton in 1669, and even earlier to the Chinese mathematician Ch&#39;in Chiu-Shao in the 13th century. TASK: write a program to calculate sum of Polynomial by Horner scheme.</p>","inputSample":"5 2\r\n0 1 2 3 4 5","inputTip":"tow lines. The first line have tow numbers,n and x, n< =20, x< =10 The second line have n+1 numbers, a0,a1...an.","judgeModel":0,"level":0,"limitMemory":65535,"limitTime":1000,"outputSample":"258","outputTip":"The sum of Polynomial","probId":28,"standardSource":"#include \"stdio.h\"\r\nint main()\r\n{\r\n\tint n,x,i,sum,a[30];\r\n\tscanf(\"%d%d\",&n,&x);\r\n\tfor ( i=0 ; i<=n ; i++ )\r\n\t\tscanf(\"%d\",&a[i]);\r\n\tsum=a[n];\r\n\twhile ( n )\r\n\t{\r\n\t\tsum*=x;\r\n\t\tsum+=a[n-1];\r\n\t\tn--;\r\n\t}\r\n\tprintf(\"%d\\n\",sum);\r\n\treturn 0;\r\n}","testdataNum":null,"title":"Horner scheme","totalSubmit":236},{"acedNum":0,"author":null,"codeLimit":0,"createTime":"2012-09-01 09:36:11","description":"<p>n个元素{1,2,..., n }有n!个不同的排列。将这n!个排列按字典序排列，并编号为0，1，&hellip;，n!-1。每个排列的编号为其字典序值。例如，当n=3时，6 个不同排列的字典序值如下：&nbsp;</p>\r\n<p>0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp; 5</p>\r\n<p>123 132 213 231 312 321</p>\r\n<p>任务：给定n 以及n 个元素{1,2,..., n }的一个排列，计算出这个排列的字典序值，以及按字典序排列的下一个排列。</p>","inputSample":"8\r\n2 6 4 5 8 1 7 3","inputTip":"<p>第1 行是元素个数n(n &lt; 15)。接下来的1 行是n个元素{1,2,..., n }的一个排列。</p>","judgeModel":0,"level":2,"limitMemory":65535,"limitTime":2000,"outputSample":"8227\r\n2 6 4 5 8 3 1 7","outputTip":"<p>第一行是字典序值，第2行是按字典序排列的下一个排列。</p>","probId":29,"standardSource":"//\t\\\t|\r\n#include<stdio.h>\r\n#include<stdlib.h>\r\nint permutation_index(int a[],int n)\r\n{\r\n\tint i,j,index;\r\n\tint *b=(int *)calloc(n,sizeof(int));\r\n\tfor(i=0;i<n;i++)\r\n\t{\r\n\t\tindex=1;\r\n\t\tfor(j=0;j<i;j++)if(a[j]<a[i])index++;\r\n\t\tb[i]=a[i]-index;\r\n\t}\r\n\tj=1;\tindex=0;\r\n\tfor(i=n-1;i>=0;i--)\r\n\t{\r\n\t\tindex+=b[i]*j;\r\n\t\tj*=(n-i);\r\n\t}\r\n\treturn index;\r\n}\r\nint next_permutation(int a[],int n)\r\n{\r\n\tint i,i1,i2;\r\n\t//int *b=(int *)calloc(n,sizeof(int));\r\n\t//for(i=0;i<n;i++)b[i]=a[i];\r\n\tfor(i=n-2;i>=0;i--)if(a[i]<a[i+1])break;\r\n\tif(i==-1)return -1;\r\n\ti1=i;\ti2=n-i;\r\n\tint *c=(int *)calloc(i2,sizeof(int));\r\n\tfor(i=0;i<i2;i++)c[i]=a[i1+i];\r\n\tinsert_sort(c,i2);\r\n\tfor(i=0;i<i2&&c[i]!=a[i1];)a[i1+i+1]=c[i++];\r\n\ta[i1+i+1]=c[i++];\r\n\ta[i1]=c[i++];\r\n\twhile(i<i2)a[i1+i]=c[i++];\r\n\treturn 0;\r\n}\r\nint insert_sort(int a[],int n)\r\n{\r\n\tint i,j,temp;\r\n\tfor(i=1;i<n;i++)\r\n\t{\r\n\t\ttemp=a[i];\r\n\t\tfor(j=i-1;j>=0&&a[j]>temp;j--)a[j+1]=a[j];\r\n\t\ta[j+1]=temp;\r\n\t}\r\n\treturn 0;\r\n}\r\nint main(int argc,char* argv[])\r\n{\r\n\tint n,i;\r\n\tscanf(\"%i\",&n);\r\n\tint *a=(int *)calloc(n,sizeof(int));\r\n\tfor(i=0;i<n;i++)scanf(\"%i\",a+i);\r\n\ti=permutation_index(a,n);\r\n\tprintf(\"%i\\n\",i);\r\n\tnext_permutation(a,n);\r\n\tfor(i=0;i<n;i++)printf(\"%i \",a[i]);\r\n\treturn 0;\r\n}","testdataNum":null,"title":"排列的字典序问题","totalSubmit":0},{"acedNum":0,"author":null,"codeLimit":0,"createTime":"2012-09-01 09:36:11","description":"<p>\r\n\t跑跑卡丁车是时下一款流行的网络休闲游戏，你可以在这虚拟的世界里体验驾驶的乐趣。这款游戏的特别之处是你可以通过漂移来获得一种 加速卡，用这种加速卡可以在有限的时间里提高你的速度。为了使问题简单化，我们假设一个赛道分为L段，并且给你通过每段赛道的普通耗时Ai和用加速卡的耗时Bi。加速卡的获得机制是：普通行驶的情况下，每通过1段赛道,可以获得20%的能量(N2O).能量集满后获得一个加速卡(同时能量清0).加速卡最多可以储存2个,也就是说当你有2个加速卡而能量再次集满,那么能量清零但得不到加速卡。一个加速卡只能维持一段赛道，游戏开始时没有加速卡。 <img alt=\"\" src=\"http://acm.swust.edu.cn:8080/JudgeOnline/qupic/1267.jpg\" /> 问题是，跑完n圈最少用时为多少？</p>","inputSample":"18 1\r\n9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9\r\n8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 8 8","inputTip":"每组输入数据有3行，第一行有2个整数L( 0 < L < 100),N(0 < N < 100)分别表示一圈赛道分为L段和有N圈赛道，接下来两行分别有L个整数Ai和Bi (Ai > Bi).","judgeModel":0,"level":2,"limitMemory":65535,"limitTime":1000,"outputSample":"145","outputTip":"对于每组输入数据，输出一个整数表示最少的用时.","probId":30,"standardSource":"#include<stdio.h> \r\n#define   max_len   100 \r\nint a[max_len],b[max_len]; \r\nint dp[max_len][max_len][3][5]; \r\nint l,n; \r\nint main()\r\n{ \r\n\tint i,j,k,r; \r\n\twhile (scanf(\"%d%d\",&l,&n)!=EOF) \r\n\t{\r\n\t\ti=0; \r\n\t\twhile (i<l)\r\n\t\t{ \r\n\t\t\tscanf(\"%d\",a+i); \r\n\t\t\ti++; \r\n\t\t} \r\n\t\ti=0; \r\n\t\twhile (i<l) \r\n\t\t{ \r\n\t\t\tscanf(\"%d\",b+i); \r\n\t\t\ti++; \r\n\t\t} \r\n\r\n\t\tfor (i=0;i<2;i++) \r\n\t\t{ \r\n\t\t\tfor (j=0;j<5;j++) \r\n\t\t\t{ \r\n\t\t\t\tdp[0][0][i][j]=0; \r\n\t\t\t} \r\n\t\t} \r\n\t\tfor (i=0;i<5;i++) \r\n\t\t{ \r\n\t\t\tdp[0][1][0][j]=a[l-1]; \r\n\t\t\tdp[0][1][1][j]=b[l-1]; \r\n\t\t\tdp[0][1][2][j]=b[l-1]; \r\n\t\t} \r\n\t\tfor (i=0;i <n;i++) \r\n\t\t{ \r\n\t\t\tfor   (j=0;j<l;j++) \r\n\t\t\t{ \r\n\t\t\t\tint next_i=i; \r\n\t\t\t\tint next_j=j-1; \r\n\r\n\t\t\t\tif( j==0) \r\n\t\t\t\t{ \r\n\t\t\t\t\tnext_i=i-1; \r\n\t\t\t\t\tnext_j=l-1; \r\n\t\t\t\t} \r\n\r\n\t\t\t\tfor (k=0;k <4;++k) \r\n\t\t\t\t{ \r\n\t\t\t\t\tdp[i][j][0][k]= a[l-j-1]+dp[next_i][next_j][0][k+1]; \r\n\t\t\t\t\tdp[i][j][1][k]= a[l-j-1]+dp[next_i][next_j][1][k+1]; \r\n\t\t\t\t\tif   (dp[i][j][1][k]> b[l-j-1]+dp[next_i][next_j][0][k]) \r\n\t\t\t\t\t{     \r\n\t\t\t\t\t\tdp[i][j][1][k]=b[l-j-1]+dp[next_i][next_j][0][k]; \r\n\t\t\t\t\t} \r\n\t\t\t\t\tdp[i][j][2][k]= a[l-j-1]+dp[next_i][next_j][2][k+1]; \r\n\t\t\t\t\tif   (dp[i][j][2][k]> b[l-j-1]+dp[next_i][next_j][1][k]) \r\n\t\t\t\t\t{     \r\n\t\t\t\t\t\tdp[i][j][2][k]=b[l-j-1]+dp[next_i][next_j][1][k]; \r\n\t\t\t\t\t}   \r\n\t\t\t\t} \r\n\t\t\t\tdp[i][j][0][4]=a[l-j-1]+dp[next_i][next_j][1][0]; \r\n\t\t\t\tdp[i][j][1][4]=a[l-j-1]+dp[next_i][next_j][2][0]; \r\n\t\t\t\tif (dp[i][j][1][4]> b[l-j-1]+dp[next_i][next_j][0][4]) \r\n\t\t\t\t{\r\n\t\t\t\t\tdp[i][j][1][4]=b[l-j-1]+dp[next_i][next_j][0][4]; \r\n\t\t\t\t}\r\n\t\t\t\tdp[i][j][2][4]=a[l-j-1]+dp[next_i][next_j][2][0]; \r\n\t\t\t\tif (dp[i][j][2][4]> b[l-j-1]+dp[next_i][next_j][1][4]) \r\n\t\t\t\t{\r\n\t\t\t\t\tdp[i][j][2][4]=b[l-j-1]+dp[next_i][next_j][1][4]; \r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tprintf(\"%d\\n\",dp[n-1][l-1][0][0]); \r\n    }\r\n\treturn   0; \r\n}","testdataNum":null,"title":"跑跑卡丁车","totalSubmit":178},{"acedNum":0,"author":null,"codeLimit":0,"createTime":"2012-09-01 09:37:15","description":"<p>\r\n\tThe Boyer&ndash;Moore string search algorithm is a particularly efficient string searching algorithm. It was developed by Bob Boyer and J Strother Moore in 1977. The algorithm preprocesses the target string (key) that is being searched for, but not the string being searched (unlike some algorithms which preprocess the string to be searched, and can then amortize the expense of the preprocessing by searching repeatedly).</p>\r\n<p>\r\n\tThe execution time of the Boyer-Moore algorithm can actually be sub-linear: it doesn&#39;t need to actually check every character of the string to be searched but rather skips over some of them.</p>\r\n<p>\r\n\tGenerally the algorithm gets faster as the key being searched for becomes longer. Its efficiency derives from the fact that, with each unsuccessful attempt to find a match between the search string and the text it&#39;s searching in, it uses the information gained from that attempt to rule out as many positions of the text as possible where the string could not match.</p>\r\n<p>\r\n\t<b>How the algorithm works</b></p>\r\n<p>\r\n\tWhat people frequently find surprising about the Boyer-Moore algorithm when they first encounter it is that its verifications &ndash; its attempts to check whether a match exists at a particular position &ndash; work backwards.</p>\r\n<p>\r\n\tIf it starts a search at the beginning of a text for the word &quot;ANPANMAN&quot;, for instance, it checks the eighth position of the text to see if it contains an &quot;N&quot;. If it finds the &quot;N&quot;, it moves to the seventh position to see if that contains the last &quot;A&quot; of the word, and so on until it checks the first position of the text for a &quot;A&quot;.</p>\r\n<p>\r\n\tWhy Boyer-Moore takes this backward approach is clearer when we consider what happens if the verification fails &ndash; for instance, if instead of an &quot;N&quot; in the eighth position, we find an &quot;X&quot;. The &quot;X&quot; doesn&#39;t appear anywhere in &quot;ANPANMAN&quot;, and this means there is no match for the search string at the very start of the text &ndash; or at the next seven positions following it, since those would all fall across the &quot;X&quot; as well.</p>\r\n<p>\r\n\tAfter checking just one character, we&#39;re able to skip ahead and start looking for a match starting at the ninth position of the text, just after the &quot;X&quot;. This explains why the best-case performance of the algorithm, for a text of length N and a fixed pattern of length M, is N/M: in the best case, only one in M characters needs to be checked.</p>\r\n<p>\r\n\tThis also explains the somewhat counter-intuitive result that the longer the pattern we are looking for, the faster the algorithm will be usually able to find it. The algorithm precomputes two tables to process the information it obtains in each failed verification: one table calculates how many positions ahead to start the next search based on the identity of the character that caused the match attempt to fail; the other makes a similar calculation based on how many characters were matched successfully before the match attempt failed. (Because these two tables return results indicating how far ahead in the text to &quot;jump&quot;, they are sometimes called &quot;jump tables&quot;, which should not be confused with the more common meaning of jump tables in computer science.)</p>\r\n<p>\r\n\t<b>the first table</b></p>\r\n<p>\r\n\tThe first table is easy to calculate: Start at the last character of the sought string and move towards the first character. Each time you move left, if the character you are on is not in the table already, add it; its Shift value is its distance from the rightmost character. All other characters receive a count equal to the length of the search string. The amount of shift calculated by the first table is sometimes called the &quot;bad character shift&quot;[1].</p>\r\n<p>\r\n\t<b>the second table</b></p>\r\n<p>\r\n\tThe second table is slightly more difficult to calculate: for each value of i less than the length of the search string, we must first calculate the pattern consisting of the last i characters of the search string, preceded by a mis-match for the character before it; then we initially line it up with the search pattern and determine the least number of characters the partial pattern must be shifted left before the two patterns match.</p>\r\n<p>\r\n\tFor instance, for the search string ANPANMAN, the table would be as follows: (N signifies any character that is not N) The amount of shift calculated by the second table is sometimes called the &quot;good suffix shift&quot;[2] or &quot;(strong) good suffix rule&quot;.</p>\r\n<p>\r\n\tThe original published Boyer-Moor algorithm [1] uses a simpler, weaker, version of the good suffix rule in which each entry in the above table did not require a mis-match for the left-most character. This is sometimes called the &quot;weak good suffix rule&quot; and is not sufficient for proving that Boyer-Moore runs in linear worst-case time.</p>\r\n<p>\r\n\t<b>Performance of the Boyer-Moore string search algorithm</b></p>\r\n<p>\r\n\tThe worst-case to find all occurrences in a text needs approximately 3*N comparisons, hence the complexity is O(n), regardless whether the text contains a match or not. The proof is due to Richard Cole, see R. COLE, Tight bounds on the complexity of the Boyer-Moore algorithm, Proceedings of the 2nd Annual ACM-SIAM Symposium on Discrete Algorithms, (1991) for details. This proof took some years to determine. In the year the algorithm was devised, 1977, the maximum number of comparisons was shown to be no more than 6*N; in 1980 it was shown to be no more than 4*N, until Cole&#39;s result in 1991.</p>\r\n<p>\r\n\t<b>References</b></p>\r\n<p>\r\n\t1. ^ R. S. Boyer; J. S. Moore (1977). &quot;A fast string searching algorithm&quot;. Comm. ACM 20: 762-772.</p>","inputSample":"GGCCTCATATCTCTCT\r\nCCCATTGGCCTCATATCTCTCTCCCTCCCTCCCCTGCCCAGGCTGCTTGGCATGG","inputTip":"two lines and only characters “ACGT” in the string.\r\nthe first line is string (< = 102000)\r\nthe second line is text(< = 700000)","judgeModel":0,"level":1,"limitMemory":65535,"limitTime":1000,"outputSample":"6","outputTip":"position of the string in text\r\nelse -1","probId":31,"standardSource":"#include <stdio.h>\r\n#include <string.h>\r\nvoid Get_next(char *p, int *next)\r\n{\r\n\tint i,j,slen;\r\n\tslen = strlen(p);\r\n\ti=0;\r\n\tnext[0]=-1;\r\n\tj=-1;\r\n\twhile (i < slen)\r\n\t\tif (j==-1 || p[i]==p[j])\r\n\t\t{\r\n\t\t\t++i;\r\n\t\t\t++j;\r\n\t\t\tnext[i]=j;\r\n\t\t}\r\n\t\telse j=next[j];\r\n}\r\nint Index(char *s, char *t, int pos)\r\n{\r\n\tint i,j,next[120],slen,tlen;\r\n\tslen = strlen(s);\r\n\ttlen = strlen(t);\r\n\tGet_next(t,next);\r\n\ti = pos;\r\n\tj = 0;\r\n\twhile (i < slen && j < tlen)\r\n\t\tif (j == -1 || s[i] == t[j])\r\n\t\t{\r\n\t\t\ti++;\r\n\t\t\tj++;\r\n\t\t}\r\n\t\telse j = next[j];\r\n    \treturn i-tlen;\r\n}\r\n\r\nint main()\r\n{\r\n\tchar s[4500],t[120];\r\n\tint location;\r\n\tgets(t);\r\n\tgets(s);\r\n\tlocation = Index(s,t,0)+1;\r\n\tprintf(\"%d\\n\",location);\r\n\treturn 0;\r\n}","testdataNum":null,"title":"Boyer–Moore–Horspool algorithm","totalSubmit":577},{"acedNum":0,"author":null,"codeLimit":0,"createTime":"2012-09-01 09:37:15","description":"<p>\r\n\t长江游艇俱乐部在长江上设置了n 个游艇出租站1，2，&hellip;，n。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i 到游艇出租站j 之间的租金为r(i,j),1&lt; =i&lt; j &lt; =n。试设计一个算法，计算出从游艇出租站1 到游艇出租站n 所需的最少租金。</p>","inputSample":"3\r\n5 15\r\n7","inputTip":"第1 行中有1 个正整数n（n&lt;=200），表示有n个游艇出租站。接下来的n-1 行是r(i,j),1&lt; =i&lt; j &lt; =n。","judgeModel":0,"level":1,"limitMemory":65535,"limitTime":1000,"outputSample":"12","outputTip":"从游艇出租站1 到游艇出租站n所需的最少租金","probId":32,"standardSource":"#include <stdio.h>\r\n#include <string.h>\r\n#define MAX_POINT 201  \r\nint dis[MAX_POINT];\r\nint n;\r\nint map[MAX_POINT][MAX_POINT];\t\r\nint main()\r\n{int i,j;\r\nwhile(scanf(\"%d\",&n)!=EOF)\r\n\t{\r\n\t\tfor(i=1;i<=n;i++)\r\n\t\t\tfor(j=1;j<=n;j++)\r\n\t\t\t\tmap[i][j]=0;\r\n\t\tfor(i=1;i<=n;i++)\r\n\t\t\tfor(j=i+1;j<=n;j++)\r\n\t\t\t\tscanf(\"%d\",&map[i][j]),map[j][i]=map[i][j];\r\n\t\tfor(i=2;i<=n;i++)\r\n\t\t\tdis[i]=map[1][i];\r\n\t\tfor(i=2;i<=n;i++)\r\n\t\t\tfor(j=2;j<=n;j++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(i==j) continue;\r\n\t\t\t\t\tif(dis[j]>dis[i]+map[i][j])\r\n\t\t\t\t\t\tdis[j]=dis[i]+map[i][j];\r\n\t\t\t\t}\r\n\t\tprintf(\"%d\\n\",dis[n]);\r\n\t}\r\nreturn 0;\r\n}","testdataNum":null,"title":"Renting Boats","totalSubmit":287},{"acedNum":0,"author":null,"codeLimit":0,"createTime":"2012-09-01 09:37:15","description":"<p>设有n 种不同面值的硬币，各硬币的面值存于数组T［1:n］中。现要用这些面值的硬币来找钱。可以使用的各种面值的硬币个数存于数组Coins［1:n］中。 对于给定的1&le;n&le;10，硬币面值数组T和可以使用的各种面值的硬币个数数组Coins，以及钱数m，0&le;m&le;20001，编程计算找钱m的最少硬币数。</p>","inputSample":"3\r\n1 3\r\n2 3\r\n5 3\r\n18","inputTip":"<p>第一行中只有1 个整数给出n的值,第2 行起每行2 个数，分别是T[j]和Coins[j]。最后1 行是要找的钱数m。</p>","judgeModel":0,"level":1,"limitMemory":65535,"limitTime":1000,"outputSample":"5","outputTip":"<p>最少硬币数,无解时输出-1</p>","probId":33,"standardSource":"#include \"stdio.h\"\r\n#include \"iostream\"\r\nusing namespace std;\r\nint money[50]={0},c[50]={0};\r\nint want=0,have=0,i,j;\r\nint m,n,sum,temp;\r\nint main()\r\n{   scanf(\"%d\",&n);\r\n\tfor(i=1;i<n+1;i++)  scanf(\"%d%d\",&money[i],&c[i]);\r\n    scanf(\"%d\",&m);have=m;\r\n    for(i=1;i<=n;i++)\r\n        for(j=i+1;j<=n;j++)\r\n        {  \tif(money[j]<money[i])\r\n\t\t\t{  swap(money[j],money[i]);swap(c[j],c[i]); }\r\n        }\r\n    for(i=n;i>=1;i--)\r\n    {    if(m>=money[i])\r\n        {\tif((m/money[i])>=c[i]) temp=c[i];\r\n\t\t\telse temp=m/money[i];\r\n            sum=sum+temp;\r\n            want=want+temp*money[i];        \r\n            m=m-temp*money[i];\r\n\t\t\tcontinue;\r\n        }   \r\n    }\r\n    if(want==have) printf(\"%d\",sum);\r\n    else printf(\"%d\",-1);\r\n    return 0;\r\n}","testdataNum":null,"title":"Coin Changing","totalSubmit":427},{"acedNum":0,"author":null,"codeLimit":0,"createTime":"2012-09-01 09:37:15","description":"<p>\r\n\tA chess rook can move horizontally o r vertically to any square in the same row o r in the same column of a chessboard. Find the number of shortest paths by which a rook can move from one corner of a chessboard to the diagonally opposite corner。</p>","inputSample":"4","inputTip":"a interger number n is row and column of chessboard. 0<= n<=16","judgeModel":0,"level":0,"limitMemory":65535,"limitTime":1000,"outputSample":"20","outputTip":"the number of shortest paths.","probId":34,"standardSource":"#include<stdio.h>\r\nint main()\r\n{\r\n\tint n;\r\n\tscanf(\"%d\",&n);\r\n\tlong long f(int m,int n);\r\n\tprintf(\"%lld\\n\",f(2*n-2,n-1));\r\n\treturn 0;\r\n}\r\nlong long f(int x,int y)\r\n{\r\n\tlong long d;\r\n\tif(y==0)d=1;\r\n\telse d=f(x,y-1)*(x-y+1)/y;\r\n\treturn d;\r\n}","testdataNum":null,"title":"Shortest path counting","totalSubmit":176},{"acedNum":0,"author":null,"codeLimit":0,"createTime":"2012-09-01 09:37:15","description":"<p>\r\n\t设有n 个程序{1,2,&hellip;, n }要存放在长度为L的磁带上。程序i存放在磁带上的长度是l<sub>i</sub> ，1 &lt; = i &lt; = n。 程序存储问题要求确定这n 个程序在磁带上的一个存储方案，使得能够在磁带上存储尽可能多的程序。在保证存储最多程序的前提下还要求磁带的利用率达到最大。 对于给定的n个程序存放在磁带上的长度，编程计算磁带上最多可以存储的程序数和占用磁带的长度。</p>","inputSample":"9 50\r\n2 3 13 8 80 20 21 22 23","inputTip":"第一行是2 个正整数，分别表示文件个数n &lt;=600和磁带的长度L&lt;=6000。接下来的1 行中，有n个正整数，表示程序存放在磁带上的长度。","judgeModel":0,"level":1,"limitMemory":65535,"limitTime":1000,"outputSample":"5 49\r\n2 3 13 8 23","outputTip":"第1 行输出最多可以存储的程序数和占用磁带的长度；第2行输出存放在磁带上的每个程序的长度。","probId":35,"standardSource":"#include<iostream>\r\nusing namespace std;\r\nint n; \r\nint c;\r\nint *p;\r\nint *w;\r\nint *x;\r\nint *best_x,best_w,best_p;\r\nint a[10000][800]={0};\r\nint b[10000][2]={0};\r\nint mmm=1;\r\nbool check(int i,int cw);\r\nvoid tryLoad(int i,int cw,int cp);\r\n\r\nint main()\r\n{\r\n\tint i;\r\n\tcin>>n;\r\n\tw=new int[n+1];\r\n\tp=new int[n+1];\r\n\tx=new int[n+1];\r\n\tbest_x=new int[n+1];\r\n\tbest_w=0;\r\n\tbest_p=0;\r\n\t\r\n\tcin>>c;\r\n\tfor( i=1;i<=n;i++)\r\n\t{\r\n\t\tcin>>w[i];\r\n\t\tp[i]=1;\r\n\t\tbest_x[i]=x[i]=0;\r\n\t}\r\n\t\r\n\ttryLoad(1,0,0);\r\n\tcout<<best_p<<\" \"<<best_w<<endl;\r\n\tfor (i=1;i<=mmm;i++)\r\n\t{\r\n\t\tif (b[i][1]==best_w&&b[i][0]==best_p)\r\n\t\t{\r\n\t\t\tfor (int u=1;u<=n;u++)\r\n\t\t\t{\r\n\t\t\t\tif (a[i][u]==1)\r\n\t\t\t\t{\r\n\t\t\t\t\tcout<<w[u]<<\" \";\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t\tcout<<endl;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\treturn 0;\r\n}\r\n\r\nbool check(int i,int cw)\r\n{\r\n\tif(cw+x[i]*w[i]>c)\r\n\t\treturn false;\r\n\telse\r\n\t\treturn true;\r\n}\r\n\r\nvoid tryLoad(int i,int cw,int cp)\r\n{int k;\r\n\tif(i>n)\r\n\t{\r\n\t\tfor( k=1;k<=n;k++)\r\n\t\t{\r\n\t\t\ta[mmm][k]=x[k];\r\n\t\t}\r\n\t\tb[mmm][1]=cw;b[mmm][0]=cp;\r\n\t\tmmm++;\r\n\t\tif(cp>best_p||(cw>best_w&&cp>=best_p))\r\n\t\t{\r\n\t\t\tbest_w=cw;\r\n\t\t\tbest_p=cp;\r\n\t\t}\r\n\t\t\r\n\t\tfor(k=1;k<=n;k++)\r\n\t\t\tbest_x[k]=x[k];\r\n\t}\r\n\telse\r\n\t\tfor(int j=1;j>=0;j--)\r\n\t\t{\r\n\t\t\tx[i]=j;\r\n\t\t\tif(check(i,cw))\r\n\t\t\t{\r\n\t\t\t\tcw+=x[i]*w[i];\r\n                cp+=x[i]*p[i];\r\n\t\t\t\ttryLoad(i+1,cw,cp);\r\n\t\t\t\tcw-=x[i]*w[i];\r\n\t\t\t\tcp-=x[i]*p[i];\r\n\t\t\t}\r\n\t\t}\r\n}","testdataNum":null,"title":"Maximum Tape Utilization Ratio","totalSubmit":408},{"acedNum":0,"author":null,"codeLimit":0,"createTime":"2012-09-01 09:39:18","description":"<p>\r\n\tA binary search algorithm (or binary chop) is a technique for finding a particular value in a sorted list. It makes progressively better guesses, and closes in on the sought value, by comparing an element halfway with what has been determined to be an element too low in the list and one too high in the list.</p>\r\n<p>\r\n\tA binary search finds the median element in a list, compares its value to the one you are searching for, and determines if it&rsquo;s greater than, less than, or equal to the one you want.</p>\r\n<p>\r\n\tA guess that turns out to be too high becomes the new top of the list, and one too low the new bottom of the list. The binary search&#39;s next guess is halfway between the new list&#39;s top and bottom. Pursuing this strategy iteratively, it narrows the search by a factor 2 each time, and finds your value. A binary search is an example of a divide and conquer algorithm (more specifically a decrease and conquer algorithm) and a dichotomic search (more at Search algorithm).</p>\r\n<p>\r\n\tThe most common application of binary search is to find a specific value in a sorted list. To cast this in the frame of the guessing game, realize that we are now guessing the index, or numbered place, of the value in the list. This is useful because, given the index, other data structures will contain associated information.</p>\r\n<p>\r\n\tSuppose a data structure containing the classic collection of name, address, telephone number and so forth has been accumulated, and an array is prepared containing the names, numbered from one to N. A query might be: what is the telephone number for a given name X. To answer this the array would be searched and the index (if any) corresponding to that name determined, whereupon it would be used to report the associated telephone number and so forth. Appropriate provision must be made for the name not being in the list (typically by returning an index value of zero), indeed the question of interest might be only whether X is in the list or not.</p>\r\n<p>\r\n\tIf the list of names is in sorted order, a binary search will find a given name with far fewer probes than the simple procedure of probing each name in the list, one after the other in a linear search, and the procedure is much simpler than organising a hash table though that would be faster still, typically averaging just over one probe.</p>\r\n<p>\r\n\tThis applies for a uniform distribution of search items but if it is known that some few items are much more likely to be sought for than the majority then a linear search with the list ordered so that the most popular items are first may do better.</p>\r\n<p>\r\n\tThe binary search begins by comparing the sought value X to the value in the middle of the list; because the values are sorted, it is clear whether the sought value would belong before or after that middle value, and the search then continues through the correct half in the same way.</p>\r\n<p>\r\n\tOnly the sign of the difference is inspected: there is no attempt at an interpolation search based on the size of the differences. Your task is to write a program that, given a set numbers of ascending and a key, finding a particular postion in a sorted list.</p>\r\n<p>\r\n\tYour task is simple, write a binary search program.</p>","inputSample":"10 7\r\n0 1 2 3 4 5 6 7 8 9","inputTip":"The input contains one total numbers（N<=5000000） and a find key,followed by a line containing the integer numbers ascending sets.","judgeModel":0,"level":0,"limitMemory":65535,"limitTime":5000,"outputSample":"8","outputTip":"if find the key in the sorted list, output containing postion in a sorted list, else ouput -1.","probId":36,"standardSource":"main()\r\n{int n,k;\r\nscanf(\"%d%d\",&n,&k);\r\nprintf(\"%d\\n\",k+1);\r\n\tif(k>n)\r\n\t\tputs(\"-1\");\r\n}","testdataNum":null,"title":"Binary search","totalSubmit":431},{"acedNum":0,"author":null,"codeLimit":0,"createTime":"2012-09-01 09:39:19","description":"<p>\r\n\t俄式乘法，又被称为俄国农夫法，它是对两个正整数相乘的非主流算法。假设m和n是两个正整数，我们要计算它们的积。它的主要原理如下： if n is 偶数 n * m=n/2 * 2m else n * m=(n-1)/2 * 2m + m 该算法只包括折半，加倍，相加等几个简单操作，因此实现速度非常快。</p>","inputSample":"50  65","inputTip":"两个正整数 n,m。","judgeModel":0,"level":0,"limitMemory":65535,"limitTime":1000,"outputSample":"130 + 1040 + 2080 = 3250","outputTip":"n和m的乘积。\r\n输出整个求和表达式，运算符与数字之间用一个空格隔开。","probId":37,"standardSource":"#include <iostream.h>\r\nint main()\r\n{\r\n\tunsigned long m,n,pro;\r\n\tcin>>n>>m;\r\n\tif(n%2==0)pro=n/2*(2*m);\r\n\telse pro=(n-1)/2*(2*m)+m;\r\n\tcout<<pro<<endl;\r\n\treturn 0;\r\n}","testdataNum":null,"title":"俄式乘法","totalSubmit":262},{"acedNum":0,"author":null,"codeLimit":0,"createTime":"2012-09-01 09:40:28","description":"<p>\r\n\tBefore ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid. But there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee.</p>\r\n<p>\r\n\tYour task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs!</p>","inputSample":"3\r\n10 110\r\n2\r\n1 1\r\n30 50\r\n10 110\r\n2\r\n1 1\r\n50 30\r\n1 6\r\n2\r\n10 3\r\n20 4","inputTip":"The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers E and F. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means 1 <= E <= F <= 10000. On the second line of each test case, there is an integer number N (1 <= N <= 500) that gives the number of various coins used in the given currency. Following this are exactly N lines, each specifying one coin type. These lines contain two integers each, Pand W (1 <= P <= 50000, 1 <= W <=10000). P is the value of the coin in monetary units, W is it's weight in grams.","judgeModel":0,"level":2,"limitMemory":65535,"limitTime":1000,"outputSample":"The minimum amount of money in the piggy-bank is 60.\r\nThe minimum amount of money in the piggy-bank is 100.\r\nThis is impossible.","outputTip":"Print exactly one line of output for each test case. The line must contain the sentence \"The minimum amount of money in the piggy-bank is X.\" where X is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a line \"This is impossible.\".","probId":38,"standardSource":"#include <stdio.h>\r\n#include <memory.h>\r\n#include <algorithm>\r\n#define INF 0x3fffffff\r\n#define MIN(x,y) ((x)<(y)?(x):(y))\r\nusing namespace std;\r\n\r\nint coins[510][2];\r\nint f[10100];\r\nvoid init()\r\n{\r\n\tint i;\r\n\tfor(i=0;i<10100;++i)\r\n\t\tf[i] = INF;\r\n}\r\n\r\nint main()\r\n{\r\n\tint T;\r\n\tscanf(\"%d\",&T);\r\n\twhile(T--)\r\n\t{\r\n\t\tint E,F,m,n;\r\n\t\tinit();\r\n\t\tscanf(\"%d%d\",&E,&F);\r\n\t\tm = F - E;\r\n\t\tscanf(\"%d\",&n);\r\n\t\tint i,j;\r\n\t\tfor(i=1;i<=n;++i)\tscanf(\"%d%d\",&coins[i][0],&coins[i][1]);\r\n\t\tf[m] = 0;\r\n\t\tfor(i=1;i<=n;++i)\t\r\n\t\t\tfor(j=m;j>=0;--j)\t\r\n\t\t\t\tif(j+coins[i][1] <= m) \r\n\t\t\t\t\tf[j] = MIN(f[j],f[j+coins[i][1]] + coins[i][0]);\r\n\t\tif(f[0] == INF) puts(\"This is impossible.\");\r\n\t\telse\tprintf(\"The minimum amount of money in the piggy-bank is %d.\\n\",f[0]);\r\n\t}\r\n\treturn 0;\r\n}","testdataNum":null,"title":"Piggy-Bank","totalSubmit":162},{"acedNum":0,"author":null,"codeLimit":0,"createTime":"2012-09-01 09:40:28","description":"<p>\r\n\tn the game of Jack Straws, a number of plastic or wooden &quot;straws&quot; are dumped on the table and players try to remove them one-by-one without disturbing the other straws. Here, we are only concerned with if various pairs of straws are connected by a path of touching straws. You will be given a list of the endpoints for some straws (as if they were dumped on a large piece of graph paper) and then will be asked if various pairs of straws are connected. Note that touching is connecting, but also two straws can be connected indirectly via other connected straws.</p>","inputSample":"7\r\n1 6 3 3 \r\n4 6 4 9 \r\n4 5 6 7 \r\n1 4 3 5 \r\n3 5 5 5 \r\n5 2 6 3 \r\n5 4 7 2 \r\n1 4 \r\n1 6 \r\n3 3 \r\n6 7 \r\n2 3 \r\n1 3 \r\n0 0","inputTip":"A problem consists of multiple lines of input. The first line will be an integer n (1 &lt; n &lt; 13) giving the number of straws on the table. Each of the next n lines contain 4 positive integers, x1 , y1 , x2 and y2 , giving the coordinates, (x1 ; y1 ); (x2 ; y2 ) of the endpoints of a single straw. All coordinates will be less than 100. (Note that the straws will be of varying lengths.) The first straw entered will be known as straw #1, the second as straw #2, and so on. The remaining lines of input (except for the final line) will each contain two positive integers, a and b, both between 1 and n, inclusive. You are to determine if straw a can be connected to straw b. When a = 0 = b, the input is terminated. There will be no illegal input and there are no zero-length straws.","judgeModel":0,"level":2,"limitMemory":65535,"limitTime":1000,"outputSample":"CONNECTED \r\nNOT CONNECTED \r\nCONNECTED \r\nCONNECTED \r\nNOT CONNECTED \r\nCONNECTED","outputTip":"You should generate a line of output for each line containing a pair a and b, except the final line where a = 0 = b. The line should say simply \"CONNECTED\", if straw a is connected to straw b, or \"NOT CONNECTED\", if straw a is not connected to straw b. For our purposes, a straw is considered connected to itself.","probId":39,"standardSource":"#include <stdio.h>\r\n#include <stdlib.h>\r\n#include <string.h>\r\n#define MAXSIZE 13\r\n\r\nint rank[MAXSIZE];   \r\n\r\nint parent[MAXSIZE]; \r\n\r\nint FindSet(int x){\r\n\r\n    if( x != parent[x] ) parent[x] = FindSet(parent[x]);\r\n\r\n     return parent[x];\r\n\r\n}\r\n\r\nvoid Union(int root1, int root2){\r\n\r\n     int x = FindSet(root1), y = FindSet(root2);\r\n\r\n     if( x == y ) return ;\r\n\r\n     if( rank[x] > rank[y] ) parent[y] = x;\r\n\r\n     else{\r\n\r\n         parent[x] = y;\r\n\r\n         if( rank[x] == rank[y] ) ++rank[y];\r\n\r\n     }\r\n\r\n}\r\n\r\nvoid Initi(void){\r\n     int i;\r\n     memset(rank, 0, sizeof(rank));\r\n\r\n     for(  i=0; i < MAXSIZE; ++i ) parent[i] = i;\r\n\r\n}\r\n\r\n\r\nstruct point\r\n{\r\n    int x;\r\n    int y;\r\n};\r\ntypedef struct point point;\r\nstruct v{\r\n    struct point start;\r\n    struct point end;\r\n};\r\ntypedef struct v v;\r\nstruct v seg[13];\r\nint crossProduct(point * v1, point* v2){\r\n\r\n    return v1->x*v2->y-v2->x*v1->y;\r\n}\r\n\r\nint direction(point* pi, point* pj, point* pk){\r\n     point p1, p2;\r\n\r\n     p1.x = pk->x - pi->x;\r\n     p1.y = pk->y - pi->y;\r\n\r\n     p2.x = pj->x - pi->x;\r\n     p2.y = pj->y - pi->y;\r\n\r\n    return crossProduct(&p1, &p2);\r\n}\r\n\r\nint onSegment(point* pi, point* pj, point* pk){\r\n    int minx, miny, maxx, maxy;\r\n    if (pi->x > pj->x){\r\n         minx = pj->x;\r\n         maxx = pi->x;\r\n     }\r\n    else{\r\n         minx = pi->x;\r\n         maxx = pj->x;\r\n     }\r\n\r\n    if (pi->y > pj->y){\r\n         miny = pj->y;\r\n         maxy = pi->y;\r\n     }\r\n    else{\r\n         miny = pi->y;\r\n         maxy = pj->y;\r\n     }\r\n\r\n    if (minx <= pk->x && pk->x <= maxx && miny <= pk->y && pk->y <= maxy)\r\n        return 1;\r\n    else\r\n        return 0;\r\n}\r\n\r\nint segmentIntersect(point* p1, point* p2, point* p3, point* p4){\r\n    int d1 = direction(p3, p4, p1);\r\n    int d2 = direction(p3, p4, p2);\r\n    int d3 = direction(p1, p2, p3);\r\n    int d4 = direction(p1, p2, p4);\r\n    if (d1 * d2 < 0 && d3 * d4 < 0)\r\n        return 1;\r\n    else if (!d1 && onSegment(p3, p4, p1))\r\n        return 1;\r\n    else if (!d2 && onSegment(p3, p4, p2))\r\n        return 1;\r\n    else if (!d3 && onSegment(p1, p2, p3))\r\n        return 1;\r\n    else if (!d4 && onSegment(p1, p2, p4))\r\n        return 1;\r\n    else\r\n        return 0;\r\n}\r\n\r\nint main()\r\n{\r\n  int n,a,b,c,d,i,j;\r\n  while(scanf(\"%d\",&n)==1&&n)\r\n  {\r\n    for(i=0;i<n;i++)\r\n     { scanf(\"%d%d%d%d\",&a,&b,&c,&d);\r\n       seg[i].start.x=a;\r\n       seg[i].start.y=b;\r\n       seg[i].end.x=c;\r\n       seg[i].end.y=d;\r\n     }\r\n     Initi();\r\n     for(i=0;i<n;i++)\r\n      for(j=i+1;j<n;j++)\r\n      {\r\n         a=segmentIntersect(&seg[i].start,&seg[i].end,&seg[j].start,&seg[j].end);\r\n          if(a)\r\n          Union(i,j);\r\n\r\n      }\r\n     while(scanf(\"%d%d\",&a,&b)==2)\r\n     {\r\n         if(a==0&&b==0)\r\n           break;\r\n         if(FindSet(a-1)==FindSet(b-1))\r\n          printf(\"CONNECTED\\n\");\r\n        else\r\n         printf(\"NOT CONNECTED\\n\");\r\n     }\r\n  }\r\n  return 0;\r\n}","testdataNum":null,"title":"Jack Straws","totalSubmit":182},{"acedNum":0,"author":null,"codeLimit":0,"createTime":"2012-09-01 09:40:28","description":"某石油公司计划建造一条由东向西的主输油管道。该管道要穿过一个有n 口油井的油田。从每口油井都要有一条输油管道沿最短路经(或南或北)与主管道相连。如果给定n口油井的位置,即它们的x 坐标（东西向）和y 坐标（南北向）,应如何确定主管道的最优位置,即使各油井到主管道之间的输油管道长度总和最小的位置?证明可在线性时间内确定主管道的最优位置。\r\n\r\n给定n 口油井的位置,编程计算各油井到主管道之间的输油管道最小长度总和。","inputSample":"5\r\n1 2\r\n2 2\r\n1 3\r\n3 -2\r\n3 3","inputTip":"第1 行是油井数n，1< =n< =10000。接下来n 行是油井的位置，每行2个整数x和y，-10000< =x，y< =10000。","judgeModel":0,"level":1,"limitMemory":65535,"limitTime":1000,"outputSample":"6","outputTip":"第1 行中的数是油井到主管道之间的输油管道最小长度总和。","probId":40,"standardSource":"#include <iostream>\r\n#include <string.h>\r\nusing namespace std;\r\n\r\nint main()\r\n{\r\n\tchar a[20];\r\n\tint i,k,n;\r\n\tvoid select(char a[],int n);\r\n\tcin>>a;\r\n\tcin>>k;\r\n\tn=strlen(a);\r\n\tselect(a,n);\r\n\tfor(i=0;i<n-k;i++)\r\n\t\tcout<<a[i];\r\n\t\tcout<<endl;\r\n\treturn 0;\r\n}\r\n\r\nvoid select(char a[],int n)\r\n{\r\n\tint i,j,k,t;\r\n\tfor(i=0;i<n-1;i++)\r\n\t{\r\n\t\tk=i;;//先假设k是最小的数字的下标\r\n\t\tfor(j=i+1;j<n;j++)\r\n\t\tif(a[j]<a[k])\r\n\t\t\tk=j;//如果后面的比前面的小的话就先交换数的下标\r\n\t\tt=a[k];\r\n\t\ta[k]=a[i];\r\n\t\ta[i]=t;//最后进行交换（共交换你n-1次）\r\n\t}\r\n}","testdataNum":null,"title":"Pipeline","totalSubmit":647},{"acedNum":0,"author":null,"codeLimit":0,"createTime":"2012-09-01 09:40:28","description":"在一个划分成网格的操场上，n个士兵散乱地站在网格点上。网格点由整数坐标(x,y)表示。士兵们可以沿网格边上、下、左、右移动一步，但在同一时刻任一网格点上只能有一名士兵。按照军官的命令，士兵们要整齐地列成一个水平队列，即排列成(x,y),(x+1,y),…,(x+n-1,y)。如何选择x 和y的值才能使士兵们以最少的总移动步数排成一列。\r\n\r\n计算使所有士兵排成一行需要的最少移动步数。","inputSample":"5\r\n1 2\r\n2 2\r\n1 3\r\n3 -2\r\n3 3","inputTip":"第1 行是油井数n，1< =n< =10000。接下来n 行是油井的位置，每行2个整数x和y，-10000< =x，y< =10000。","judgeModel":0,"level":1,"limitMemory":65535,"limitTime":1000,"outputSample":"8","outputTip":"第1 行中的数是士兵排成一行需要的最少移动步数。","probId":41,"standardSource":"#include <iostream> \r\n#include <algorithm> \r\nusing namespace std; \r\n\r\nint x[10000];\r\nint y[10000];\r\n\r\nint main() \r\n{ \r\n\tint n, i; \r\n\tscanf(\"%d\", &n);//cin >> n; \r\n\t\r\n\tfor (i = 0; i < n; ++i) \r\n\t\tscanf(\"%d%d\", &x[i], &y[i]);//cin >> x[i] >> y[i]; \r\n\t\r\n\tint tempx; \r\n\tint tempy; \r\n\t\r\n\tnth_element(y, y + n / 2, y + n); \r\n\ttempy = y[n / 2]; \r\n\t\r\n\tsort(x, x + n); \r\n\tfor (i = 0; i < n; ++i) \r\n\t\tx[i] -= i; \r\n\t\r\n\tnth_element(x, x + n / 2, x + n); \r\n\ttempx= x[n / 2]; \r\n\t\r\n\tint total = 0; \r\n\t\r\n\tfor(i = 0; i < n; ++i) { \r\n\t\ttotal += abs(y[i] - tempy); \r\n\t\ttotal += abs(x[i] - tempx); \r\n\t} \r\n\tcout << total << endl; \r\n\t\r\n\treturn 0;\r\n}","testdataNum":null,"title":"Soldiers","totalSubmit":544}],"course":[{"isCourse":1,"knowId":83,"knowName":"C程序设计","parentId":null},{"isCourse":1,"knowId":83,"knowName":"C程序设计","parentId":null},{"isCourse":1,"knowId":83,"knowName":"C程序设计","parentId":null},{"isCourse":1,"knowId":83,"knowName":"C程序设计","parentId":null},{"isCourse":1,"knowId":83,"knowName":"C程序设计","parentId":null},{"isCourse":1,"knowId":83,"knowName":"C程序设计","parentId":null},{"isCourse":1,"knowId":83,"knowName":"C程序设计","parentId":null},{"isCourse":1,"knowId":83,"knowName":"C程序设计","parentId":null},{"isCourse":1,"knowId":83,"knowName":"C程序设计","parentId":null},{"isCourse":1,"knowId":83,"knowName":"C程序设计","parentId":null},{"isCourse":1,"knowId":83,"knowName":"C程序设计","parentId":null},{"isCourse":1,"knowId":83,"knowName":"C程序设计","parentId":null},{"isCourse":1,"knowId":83,"knowName":"C程序设计","parentId":null},{"isCourse":1,"knowId":83,"knowName":"C程序设计","parentId":null},{"isCourse":1,"knowId":83,"knowName":"C程序设计","parentId":null},{"isCourse":1,"knowId":83,"knowName":"C程序设计","parentId":null},{"isCourse":1,"knowId":83,"knowName":"C程序设计","parentId":null},{"isCourse":1,"knowId":83,"knowName":"C程序设计","parentId":null},{"isCourse":1,"knowId":83,"knowName":"C程序设计","parentId":null},{"isCourse":1,"knowId":83,"knowName":"C程序设计","parentId":null}],"knowledge":[{"isCourse":0,"knowId":3,"knowName":"贪心","parentId":83},{"isCourse":0,"knowId":5,"knowName":"排序","parentId":83},{"isCourse":0,"knowId":11,"knowName":"算法基础","parentId":83},{"isCourse":0,"knowId":4,"knowName":"分治","parentId":83},{"isCourse":0,"knowId":14,"knowName":"减治","parentId":83},{"isCourse":0,"knowId":14,"knowName":"减治","parentId":83},{"isCourse":0,"knowId":12,"knowName":"变治","parentId":83},{"isCourse":0,"knowId":14,"knowName":"减治","parentId":83},{"isCourse":0,"knowId":2,"knowName":"动态规划","parentId":83},{"isCourse":0,"knowId":15,"knowName":"时空权衡","parentId":83},{"isCourse":0,"knowId":2,"knowName":"动态规划","parentId":83},{"isCourse":0,"knowId":2,"knowName":"动态规划","parentId":83},{"isCourse":0,"knowId":2,"knowName":"动态规划","parentId":83},{"isCourse":0,"knowId":3,"knowName":"贪心","parentId":83},{"isCourse":0,"knowId":14,"knowName":"减治","parentId":83},{"isCourse":0,"knowId":14,"knowName":"减治","parentId":83},{"isCourse":0,"knowId":2,"knowName":"动态规划","parentId":83},{"isCourse":0,"knowId":2,"knowName":"动态规划","parentId":83},{"isCourse":0,"knowId":4,"knowName":"分治","parentId":83},{"isCourse":0,"knowId":3,"knowName":"贪心","parentId":83}]}