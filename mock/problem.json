{
    "total": 358, 
    "data": [
        {
            "acedNum": 0, 
            "author": null, 
            "codeLimit": 0, 
            "createTime": "2012-09-01 09:28:54", 
            "description": "<p>在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。  每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所耗体力之和。  因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。  例如有3种果子，数目依次为1，2，9。可以先将1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为12。所以多多总共耗费体力=3+12=15。可以证明15为最小的体力耗费值。</p>", 
            "inputSample": "3 
1 2 9", 
            "inputTip": "<p>输入包括两行，第一行是一个整数n(1<＝n<=10000)，表示果子的种类数。第二行包含n个整数，用空格分隔，第i个整数ai(1<＝ai<=20000)是第i种果子的数目。</p>", 
            "judgeModel": 0, 
            "level": 2, 
            "limitMemory": 65535, 
            "limitTime": 1000, 
            "outputSample": "15", 
            "outputTip": "<p>输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。输入数据保证这个值小于2^31。</p>", 
            "probId": 16, 
            "standardSource": "PROGRAM MergeApple(INPUT, OUTPUT);

CONST
    MAX = 20000;
TYPE
    arr = array [1..10000] of longword;
VAR
    a : arr;
    i, n : integer;

FUNCTION Merge(a : arr; n : integer): LongWord;
    var
        lib : array [1..MAX] of integer;
        oldQueue, newQueue : arr;
        i, frontOld, frontNew, rearNew : integer;
        sum : LongWord;
    begin
        if n = 1 then
            Merge := a[1]
        else if n = 2 then
            Merge := a[1] + a[2]
        else
        begin
            //基数排序
            for i:=1 to MAX do
                lib[i] := 0;
            for i:=1 to n do
                inc(lib[a[i]]);
            n := 0;
            for i:=1 to MAX do
                while lib[i] > 0 do
                begin
                    inc(n);
                    oldQueue[n] := i;
                    dec(lib[i]);
                end; {while}

            frontOld := 1;
            frontNew := 1;
            rearNew  := 1;
            {先加上前两个}
            newQueue[rearNew] := oldQueue[frontOld] + oldQueue[frontOld+1];
            inc(frontOld, 2);
            while frontOld <= n do
            begin
                if oldQueue[frontOld] > newQueue[frontNew] then
                begin
                    sum := newQueue[frontNew];
                    inc(frontNew);
                end {if}
                else
                begin
                    sum := oldQueue[frontOld];
                    inc(frontOld);
                end; {if}

                if (frontNew <= rearNew) and (frontOld <= n) then
                begin
                    if oldQueue[frontOld] > newQueue[frontNew] then
                    begin
                        sum := sum + newQueue[frontNew];
                        inc(frontNew);
                    end {if}
                    else
                    begin
                        sum := sum + oldQueue[frontOld];
                        inc(frontOld);
                    end; {if}
                end {if}
                else if frontNew <= rearNew then
                begin
                    sum := sum + newQueue[frontNew];
                    inc(frontNew);
                end {else if}
                else
                begin
                    sum := sum + oldQueue[frontOld];
                    inc(frontOld);
                end; {else if}

                inc(rearNew);
                newQueue[rearNew] := sum;
            end; {while}

            while frontNew < rearNew do
            begin
                inc(rearNew);
                newQueue[rearNew] := newQueue[frontNew] + newQueue[frontNew+1];
                inc(frontNew, 2);
            end; {while}

            sum := 0;
            for i:=1 to rearNew do
                inc(sum, newQueue[i]);
            Merge := sum;
        end; {else}
    end; {Merge}

BEGIN
    read(n);
    for i:=1 to n do
        read(a[i]);

    writeln(Merge(a, n));
END.", 
            "testdataNum": null, 
            "title": "合并果子", 
            "totalSubmit": 0
        }, 
        {
            "acedNum": 0, 
            "author": null, 
            "codeLimit": 0, 
            "createTime": "2012-09-01 09:29:47", 
            "description": "尼克每天上班之前都连接上英特网，接收他的上司发来的邮件，这些邮件包含了尼克主管的部门当天要完成的全部任务，每个任务由一个开始时刻与一个持续时间构成。
尼克的一个工作日为N分钟，从第一分钟开始到第N分钟结束。当尼克到达单位后他就开始干活。如果在同一时刻有多个任务需要完成，尼克可以任选其中的一个来做，而其余的则由他的同事完成，反之如果只有一个任务，则该任务必需由尼克去完成，假如某些任务开始时刻尼克正在工作，则这些任务也由尼克的同事完成。如果某任务于第P分钟开始，持续时间为T分钟，则该任务将在第P+T－1分钟结束。
写一个程序计算尼克应该如何选取任务，才能获得最大的空暇时间。", 
            "inputSample": "15  6
1   2
1   6
4   11
8   5
8   1
11  5", 
            "inputTip": "输入数据第一行含一个空格隔开的整数N和K（1≤n≤10000，1≤k≤10000），N表示尼克的工作时间单位为分钟，K表示任务总数。
接下来共有K行，每一行有两个用空格隔开的整数P和T，表示该任务从第P分钟开始，持续时间为T分钟，其中1≤P≤N,1≤P+T－1≤N。", 
            "judgeModel": 0, 
            "level": 2, 
            "limitMemory": 65535, 
            "limitTime": 1000, 
            "outputSample": "4", 
            "outputTip": "输出文件仅一行，包含一个整数，表示尼克可能获得的最大空暇时间。", 
            "probId": 17, 
            "standardSource": "program p2;
const maxn=10000;

var k,i,j,n,m:longint;
     f:array[1..maxn] of longint;
     p,t:array[1..maxn] of longint;
    time:array[1..maxn,1..2] of longint;
begin
   readln(n,m);
   for i:=1 to m do
   begin
    readln(p[i],t[i]);
    if time[p[i],1]=0 then
     begin
      time[p[i],1]:=i;
      time[p[i],2]:=i;
     end
    else
     inc(time[p[i],2]);
   end;
  for i:=n downto 1 do
  begin
   if time[i,1]=0 then
     f[i]:=f[i+1]+1
    else
    begin
     k:=0;
    for j:=time[i,1] to time[i,2] do
     if f[i+t[j]]>k then
      k:=f[i+t[j]];
     f[i]:=k;
    end;
  end;
  writeln(f[1]);
end.", 
            "testdataNum": null, 
            "title": "尼克的任务", 
            "totalSubmit": 126
        }, 
        {
            "acedNum": 0, 
            "author": null, 
            "codeLimit": 0, 
            "createTime": "2012-09-01 09:29:47", 
            "description": "这是一个很简单的排序题目.
为了锻炼大家对不同算法的了解,请大家用归并排序法对此题进行解答.
对一组整数数列A[1],A[2],A[3]......A[N]进行排序,按照从小到大的顺序输出.", 
            "inputSample": "12
45 
545 
48 
47 
44 
45 
4857 
58 
57 
485 
1255 
42", 
            "inputTip": "本题只有一组测试数据,在输入的第一行输入N(表示整数数列的大小)(N ＜ 1000)
接下来N行输入N个整数,每一行一个整数.", 
            "judgeModel": 0, 
            "level": 1, 
            "limitMemory": 65535, 
            "limitTime": 1000, 
            "outputSample": "42  44  45  45  47  48  57  58  485  545
1255  4857", 
            "outputTip": "对已经排好序的数从小到大依次输出,每两个数之间用两个空格隔开,且每输出10个数换行.", 
            "probId": 20, 
            "standardSource": "#include<stdio.h>
void main()
{
int n,i,j,t,a[1000];
scanf(\"%d\",&n);
for(i=0;i<n;i++)
  scanf(\"%d\",&a[i]);
for(i=0;i<n-1;i++)
  {for(j=i+1;j<n;j++)
    if(a[i]>a[j]) {t=a[i];a[i]=a[j];a[j]=t;}
  printf(\"%d  \",a[i]);
  if(i>0&&(i+1)%10==0) printf(\"\\n\");
  }
printf(\"%d\\n\",a[i]);
}", 
            "testdataNum": null, 
            "title": "合并排序", 
            "totalSubmit": 0
        }, 
        {
            "acedNum": 0, 
            "author": null, 
            "codeLimit": 0, 
            "createTime": "2012-09-01 09:29:47", 
            "description": "在一些应用中，特别是现在的密码学中，常常需要用超过100位的整数来做乘法，以此来对数据加密。
现在有两个小于等于100位的大整数a和b（位数相同），请写程序计算出这两个大整数乘积的结果。", 
            "inputSample": "10
1111111111
1111111111", 
            "inputTip": "输入有三行
第一行是大整数位数
第一个大整数
第二个大整数", 
            "judgeModel": 0, 
            "level": 2, 
            "limitMemory": 65535, 
            "limitTime": 5000, 
            "outputSample": "1234567900987654321", 
            "outputTip": "两个大整数的结果", 
            "probId": 21, 
            "standardSource": "#include<stdio.h>
char a[100],b[100];
char c[1000],f[1000];
int main()
{
    int n,k,i;
    for(i=0;i<1000;i++) c[i]='0';
    scanf(\"%d%s%s\",&n,a,b);
    int j,d,e;
    for(i=0;i<n;i++)
    {
        e=0;
        for(j=0;j<n;j++)
        {
            d=(a[n-1-i]-'0')*(b[n-1-j]-'0')+e;
            e=d/10;
            f[j]=d%10+'0';
        }
        if(e!=0) {f[j]=e+'0';j++;e=0;}
        for(k=0;k<j;k++)
        {
            d=(f[k]-'0')+(c[k+i]-'0')+e;
            e=d/10;
            c[k+i]=d%10+'0';
        }
        for(k=j;e!=0;k++)
        {
            d=(c[k+i]-'0')+e;
            e=d/10;
            c[k+i]=d%10+'0';
        }
        d=k+i;
    }
    for(i=d-1;i>=0;i--)
        printf(\"%c\",c[i]);
    printf(\"\\n\");
    return 0;
}", 
            "testdataNum": null, 
            "title": "大整数乘法", 
            "totalSubmit": 64
        }, 
        {
            "acedNum": 0, 
            "author": null, 
            "codeLimit": 0, 
            "createTime": "2012-09-01 09:31:39", 
            "description": "<p>There are n lockers in a hallway numbered sequentially from 1 to n. Initially, all the locker doors are closed. You make n passes by the lockers, each time starting with locker #1. On the ith pass, i = 1, 2, ..., n, you toggle the door of every ith locker: if the door is closed, you open it, if it is open, you close it. For example, after the first pass every door is open; on the second pass you only toggle the even-numbered lockers (#2, #4, ...) so that after the second pass the even doors are closed and the odd ones are opened; the third time through you close the door of locker #3 (opened from the first pass), open the door of locker #6 (closed from the second pass), and so on. After the last pass, which locker doors are open and which are closed? How many of them are open? Your task is write a program to output How many doors are open after the last pass? Assumptions all doors are closed at first.</p>", 
            "inputSample": "10", 
            "inputTip": "a positive numbers n, total doors. n<=100000", 
            "judgeModel": 0, 
            "level": 1, 
            "limitMemory": 65535, 
            "limitTime": 1000, 
            "outputSample": "3", 
            "outputTip": "a positive numbers ，the total of doors opened after the last pass.", 
            "probId": 22, 
            "standardSource": "#include<stdio.h>
#include<cmath>
int main(){int n;scanf(\"%d\",&n);printf(\"%d\\n\",int(sqrt(n)));return 0;}", 
            "testdataNum": null, 
            "title": "Locker doors", 
            "totalSubmit": 469
        }, 
        {
            "acedNum": 0, 
            "author": null, 
            "codeLimit": 0, 
            "createTime": "2012-09-01 09:31:39", 
            "description": "　　在一个按照东西和南北方向划分成规整街区的城市里，n个居民点散乱地分布在不同的街区中。用x 坐标表示东西向，用y坐标表示南北向。各居民点的位置可以由坐标(x,y)表示。

　　街区中任意2 点(x1,y1)和(x2,y2)之间的距离可以用数值|x1-x2|+|y1-y2|度量。

　　居民们希望在城市中选择建立邮局的最佳位置，使n个居民点到邮局的距离总和最小。

　　任务：给定n 个居民点的位置,编程计算n 个居民点到邮局的距离总和的最小值。", 
            "inputSample": "5
1 2
2 2
1 3
3 -2
3 3", 
            "inputTip": "　　第1 行是居民点数n，1 < = n < =10000。接下来n 行是居民点的位置，每行2 个整数x 和y，-10000 < =x，y < =10000。", 
            "judgeModel": 0, 
            "level": 1, 
            "limitMemory": 65535, 
            "limitTime": 1000, 
            "outputSample": "10", 
            "outputTip": "n 个居民点到邮局的距离总和的最小值。", 
            "probId": 25, 
            "standardSource": "int main(){}", 
            "testdataNum": null, 
            "title": "PostOffice", 
            "totalSubmit": 492
        }, 
        {
            "acedNum": 0, 
            "author": null, 
            "codeLimit": 0, 
            "createTime": "2012-09-01 09:33:55", 
            "description": "<p>
    The problem is named after Flavius Josephus, a Jewish historian who participated in and chronicled the Jewish revolt of 66-70C.E. against the Romans. Josephus, as a general, managed to hold the fortress of Jotapata for 47days, but after the fall of the city he took refuge with 40 diehards in a nearby cave. There the rebels voted to perish rather than surrender. Josephus proposed that each man in turn should dispatch his neighbor, the order to be determined by casting lots. Josephus contrived to draw the last lot, and as one of the two surviving men in the cave, he prevailed upon his intended victim to surrender to the Romans.</p>
<p>
    Your task:computint the position of the survivor when there are initially n people.</p>", 
            "inputSample": "6", 
            "inputTip": "a Positive Integer n is initially  people. n< = 50000", 
            "judgeModel": 0, 
            "level": 0, 
            "limitMemory": 65535, 
            "limitTime": 1000, 
            "outputSample": "5", 
            "outputTip": "the position of the survivor", 
            "probId": 26, 
            "standardSource": "#include <stdio.h>
#include \"stdlib.h\"
void main() 
{ 
    int n,i,s=0;
    scanf(\"%d\", &n); 
    for (i=2; i<=n; i++) 
        s=(s+2)%i; 
    printf (\"%d\\n\", s+1); 
}", 
            "testdataNum": null, 
            "title": "The Josephus Problem", 
            "totalSubmit": 258
        }, 
        {
            "acedNum": 0, 
            "author": null, 
            "codeLimit": 0, 
            "createTime": "2012-09-01 09:33:55", 
            "description": "<p>
    A worst-case linear algorithm for the general case of selecting the kth largest element was published by Blum, Floyd, Pratt, Rivest, and Tarjan in their 1973 paper Time bounds for selection. The algorithm that it is based on was conceived by the inventor of quicksort, C.A.R. Hoare, and are known as Hoare's selection algorithm. In quicksort, there is a subprocedure called partition which can, in linear time, group the list into two parts, those less than a certain value (left), and those greater than or equal to a certain value (right, which ends up containing pivotValue). Your task: selecting the kth largest element in a list of n numbers. (n< = 50000)</p>", 
            "inputSample": "9 5
4 1 10 9 7 12 8 2 15", 
            "inputTip": "two lines 
the first line have two numbers , the first numbers is total of list and  the second numbers is the kth largest element
the second line is a list of n numbers", 
            "judgeModel": 0, 
            "level": 1, 
            "limitMemory": 65535, 
            "limitTime": 1000, 
            "outputSample": "8", 
            "outputTip": "the kth largest element in a list of n numbers", 
            "probId": 27, 
            "standardSource": "#include <algorithm>
#include <vector>
using namespace std;

int main()
{
    int n,k;
    
    scanf(\"%d%d\",&n,&k);
    getchar();
    
    int i,input;
    vector<int> num_list;
    
    for (i=1;i<=n;++i)
    {
        scanf(\"%d\",&input);
        num_list.push_back(input);
    }

    vector<int>::iterator pt;

    nth_element(num_list.begin(),num_list.begin()+k-1,num_list.end());

    printf(\"%d\\n\",*(num_list.begin()+k-1));

    return 0;
}", 
            "testdataNum": null, 
            "title": "Partition-based general selectio", 
            "totalSubmit": 256
        }, 
        {
            "acedNum": 0, 
            "author": null, 
            "codeLimit": 0, 
            "createTime": "2012-09-01 09:36:11", 
            "description": "<p>In numerical analysis, the Horner scheme or Horner algorithm, named after William George Horner, is an algorithm for the efficient evaluation of polynomials in monomial form. Horner's method describes a manual process by which one may approximate the roots of a polynomial equation. The Horner scheme can also be viewed as a fast algorithm for dividing a polynomial by a linear polynomial with Ruffini's rule.</p>

<p><strong>Application</strong></p>

<p>The Horner scheme is often used to convert between different positional numeral systems — in which case x is the base of the number system, and the ai coefficients are the digits of the base-x representation of a given number — and can also be used if x is a matrix, in which case the gain in computational efficiency is even greater.</p>

<p><strong>History</strong></p>

<p>Even though the algorithm is named after William George Horner, who described it in 1819, the method was already known to Isaac Newton in 1669, and even earlier to the Chinese mathematician Ch'in Chiu-Shao in the 13th century. TASK: write a program to calculate sum of Polynomial by Horner scheme.</p>", 
            "inputSample": "5 2
0 1 2 3 4 5", 
            "inputTip": "tow lines. The first line have tow numbers,n and x, n< =20, x< =10 The second line have n+1 numbers, a0,a1...an.", 
            "judgeModel": 0, 
            "level": 0, 
            "limitMemory": 65535, 
            "limitTime": 1000, 
            "outputSample": "258", 
            "outputTip": "The sum of Polynomial", 
            "probId": 28, 
            "standardSource": "#include \"stdio.h\"
int main()
{
    int n,x,i,sum,a[30];
    scanf(\"%d%d\",&n,&x);
    for ( i=0 ; i<=n ; i++ )
        scanf(\"%d\",&a[i]);
    sum=a[n];
    while ( n )
    {
        sum*=x;
        sum+=a[n-1];
        n--;
    }
    printf(\"%d\\n\",sum);
    return 0;
}", 
            "testdataNum": null, 
            "title": "Horner scheme", 
            "totalSubmit": 236
        }, 
        {
            "acedNum": 0, 
            "author": null, 
            "codeLimit": 0, 
            "createTime": "2012-09-01 09:36:11", 
            "description": "<p>n个元素{1,2,..., n }有n!个不同的排列。将这n!个排列按字典序排列，并编号为0，1，…，n!-1。每个排列的编号为其字典序值。例如，当n=3时，6 个不同排列的字典序值如下： </p>
<p>0       1     2    3     4    5</p>
<p>123 132 213 231 312 321</p>
<p>任务：给定n 以及n 个元素{1,2,..., n }的一个排列，计算出这个排列的字典序值，以及按字典序排列的下一个排列。</p>", 
            "inputSample": "8
2 6 4 5 8 1 7 3", 
            "inputTip": "<p>第1 行是元素个数n(n < 15)。接下来的1 行是n个元素{1,2,..., n }的一个排列。</p>", 
            "judgeModel": 0, 
            "level": 2, 
            "limitMemory": 65535, 
            "limitTime": 2000, 
            "outputSample": "8227
2 6 4 5 8 3 1 7", 
            "outputTip": "<p>第一行是字典序值，第2行是按字典序排列的下一个排列。</p>", 
            "probId": 29, 
            "standardSource": "//   \\  |
#include<stdio.h>
#include<stdlib.h>
int permutation_index(int a[],int n)
{
    int i,j,index;
    int *b=(int *)calloc(n,sizeof(int));
    for(i=0;i<n;i++)
    {
        index=1;
        for(j=0;j<i;j++)if(a[j]<a[i])index++;
        b[i]=a[i]-index;
    }
    j=1;    index=0;
    for(i=n-1;i>=0;i--)
    {
        index+=b[i]*j;
        j*=(n-i);
    }
    return index;
}
int next_permutation(int a[],int n)
{
    int i,i1,i2;
    //int *b=(int *)calloc(n,sizeof(int));
    //for(i=0;i<n;i++)b[i]=a[i];
    for(i=n-2;i>=0;i--)if(a[i]<a[i+1])break;
    if(i==-1)return -1;
    i1=i;   i2=n-i;
    int *c=(int *)calloc(i2,sizeof(int));
    for(i=0;i<i2;i++)c[i]=a[i1+i];
    insert_sort(c,i2);
    for(i=0;i<i2&&c[i]!=a[i1];)a[i1+i+1]=c[i++];
    a[i1+i+1]=c[i++];
    a[i1]=c[i++];
    while(i<i2)a[i1+i]=c[i++];
    return 0;
}
int insert_sort(int a[],int n)
{
    int i,j,temp;
    for(i=1;i<n;i++)
    {
        temp=a[i];
        for(j=i-1;j>=0&&a[j]>temp;j--)a[j+1]=a[j];
        a[j+1]=temp;
    }
    return 0;
}
int main(int argc,char* argv[])
{
    int n,i;
    scanf(\"%i\",&n);
    int *a=(int *)calloc(n,sizeof(int));
    for(i=0;i<n;i++)scanf(\"%i\",a+i);
    i=permutation_index(a,n);
    printf(\"%i\\n\",i);
    next_permutation(a,n);
    for(i=0;i<n;i++)printf(\"%i \",a[i]);
    return 0;
}", 
            "testdataNum": null, 
            "title": "排列的字典序问题", 
            "totalSubmit": 0
        }, 
        {
            "acedNum": 0, 
            "author": null, 
            "codeLimit": 0, 
            "createTime": "2012-09-01 09:36:11", 
            "description": "<p>
    跑跑卡丁车是时下一款流行的网络休闲游戏，你可以在这虚拟的世界里体验驾驶的乐趣。这款游戏的特别之处是你可以通过漂移来获得一种 加速卡，用这种加速卡可以在有限的时间里提高你的速度。为了使问题简单化，我们假设一个赛道分为L段，并且给你通过每段赛道的普通耗时Ai和用加速卡的耗时Bi。加速卡的获得机制是：普通行驶的情况下，每通过1段赛道,可以获得20%的能量(N2O).能量集满后获得一个加速卡(同时能量清0).加速卡最多可以储存2个,也就是说当你有2个加速卡而能量再次集满,那么能量清零但得不到加速卡。一个加速卡只能维持一段赛道，游戏开始时没有加速卡。 <img alt=\"\" src=\"http://acm.swust.edu.cn:8080/JudgeOnline/qupic/1267.jpg\" /> 问题是，跑完n圈最少用时为多少？</p>", 
            "inputSample": "18 1
9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9
8 8 8 8 8 8 8 8 8 8 8 8 8 8 1 1 8 8", 
            "inputTip": "每组输入数据有3行，第一行有2个整数L( 0 < L < 100),N(0 < N < 100)分别表示一圈赛道分为L段和有N圈赛道，接下来两行分别有L个整数Ai和Bi (Ai > Bi).", 
            "judgeModel": 0, 
            "level": 2, 
            "limitMemory": 65535, 
            "limitTime": 1000, 
            "outputSample": "145", 
            "outputTip": "对于每组输入数据，输出一个整数表示最少的用时.", 
            "probId": 30, 
            "standardSource": "#include<stdio.h> 
#define   max_len   100 
int a[max_len],b[max_len]; 
int dp[max_len][max_len][3][5]; 
int l,n; 
int main()
{ 
    int i,j,k,r; 
    while (scanf(\"%d%d\",&l,&n)!=EOF) 
    {
        i=0; 
        while (i<l)
        { 
            scanf(\"%d\",a+i); 
            i++; 
        } 
        i=0; 
        while (i<l) 
        { 
            scanf(\"%d\",b+i); 
            i++; 
        } 

        for (i=0;i<2;i++) 
        { 
            for (j=0;j<5;j++) 
            { 
                dp[0][0][i][j]=0; 
            } 
        } 
        for (i=0;i<5;i++) 
        { 
            dp[0][1][0][j]=a[l-1]; 
            dp[0][1][1][j]=b[l-1]; 
            dp[0][1][2][j]=b[l-1]; 
        } 
        for (i=0;i <n;i++) 
        { 
            for   (j=0;j<l;j++) 
            { 
                int next_i=i; 
                int next_j=j-1; 

                if( j==0) 
                { 
                    next_i=i-1; 
                    next_j=l-1; 
                } 

                for (k=0;k <4;++k) 
                { 
                    dp[i][j][0][k]= a[l-j-1]+dp[next_i][next_j][0][k+1]; 
                    dp[i][j][1][k]= a[l-j-1]+dp[next_i][next_j][1][k+1]; 
                    if   (dp[i][j][1][k]> b[l-j-1]+dp[next_i][next_j][0][k]) 
                    {     
                        dp[i][j][1][k]=b[l-j-1]+dp[next_i][next_j][0][k]; 
                    } 
                    dp[i][j][2][k]= a[l-j-1]+dp[next_i][next_j][2][k+1]; 
                    if   (dp[i][j][2][k]> b[l-j-1]+dp[next_i][next_j][1][k]) 
                    {     
                        dp[i][j][2][k]=b[l-j-1]+dp[next_i][next_j][1][k]; 
                    }   
                } 
                dp[i][j][0][4]=a[l-j-1]+dp[next_i][next_j][1][0]; 
                dp[i][j][1][4]=a[l-j-1]+dp[next_i][next_j][2][0]; 
                if (dp[i][j][1][4]> b[l-j-1]+dp[next_i][next_j][0][4]) 
                {
                    dp[i][j][1][4]=b[l-j-1]+dp[next_i][next_j][0][4]; 
                }
                dp[i][j][2][4]=a[l-j-1]+dp[next_i][next_j][2][0]; 
                if (dp[i][j][2][4]> b[l-j-1]+dp[next_i][next_j][1][4]) 
                {
                    dp[i][j][2][4]=b[l-j-1]+dp[next_i][next_j][1][4]; 
                }
            }
        }
        printf(\"%d\\n\",dp[n-1][l-1][0][0]); 
    }
    return   0; 
}", 
            "testdataNum": null, 
            "title": "跑跑卡丁车", 
            "totalSubmit": 178
        }, 
        {
            "acedNum": 0, 
            "author": null, 
            "codeLimit": 0, 
            "createTime": "2012-09-01 09:37:15", 
            "description": "<p>
    The Boyer–Moore string search algorithm is a particularly efficient string searching algorithm. It was developed by Bob Boyer and J Strother Moore in 1977. The algorithm preprocesses the target string (key) that is being searched for, but not the string being searched (unlike some algorithms which preprocess the string to be searched, and can then amortize the expense of the preprocessing by searching repeatedly).</p>
<p>
    The execution time of the Boyer-Moore algorithm can actually be sub-linear: it doesn't need to actually check every character of the string to be searched but rather skips over some of them.</p>
<p>
    Generally the algorithm gets faster as the key being searched for becomes longer. Its efficiency derives from the fact that, with each unsuccessful attempt to find a match between the search string and the text it's searching in, it uses the information gained from that attempt to rule out as many positions of the text as possible where the string could not match.</p>
<p>
    <b>How the algorithm works</b></p>
<p>
    What people frequently find surprising about the Boyer-Moore algorithm when they first encounter it is that its verifications – its attempts to check whether a match exists at a particular position – work backwards.</p>
<p>
    If it starts a search at the beginning of a text for the word "ANPANMAN", for instance, it checks the eighth position of the text to see if it contains an "N". If it finds the "N", it moves to the seventh position to see if that contains the last "A" of the word, and so on until it checks the first position of the text for a "A".</p>
<p>
    Why Boyer-Moore takes this backward approach is clearer when we consider what happens if the verification fails – for instance, if instead of an "N" in the eighth position, we find an "X". The "X" doesn't appear anywhere in "ANPANMAN", and this means there is no match for the search string at the very start of the text – or at the next seven positions following it, since those would all fall across the "X" as well.</p>
<p>
    After checking just one character, we're able to skip ahead and start looking for a match starting at the ninth position of the text, just after the "X". This explains why the best-case performance of the algorithm, for a text of length N and a fixed pattern of length M, is N/M: in the best case, only one in M characters needs to be checked.</p>
<p>
    This also explains the somewhat counter-intuitive result that the longer the pattern we are looking for, the faster the algorithm will be usually able to find it. The algorithm precomputes two tables to process the information it obtains in each failed verification: one table calculates how many positions ahead to start the next search based on the identity of the character that caused the match attempt to fail; the other makes a similar calculation based on how many characters were matched successfully before the match attempt failed. (Because these two tables return results indicating how far ahead in the text to "jump", they are sometimes called "jump tables", which should not be confused with the more common meaning of jump tables in computer science.)</p>
<p>
    <b>the first table</b></p>
<p>
    The first table is easy to calculate: Start at the last character of the sought string and move towards the first character. Each time you move left, if the character you are on is not in the table already, add it; its Shift value is its distance from the rightmost character. All other characters receive a count equal to the length of the search string. The amount of shift calculated by the first table is sometimes called the "bad character shift"[1].</p>
<p>
    <b>the second table</b></p>
<p>
    The second table is slightly more difficult to calculate: for each value of i less than the length of the search string, we must first calculate the pattern consisting of the last i characters of the search string, preceded by a mis-match for the character before it; then we initially line it up with the search pattern and determine the least number of characters the partial pattern must be shifted left before the two patterns match.</p>
<p>
    For instance, for the search string ANPANMAN, the table would be as follows: (N signifies any character that is not N) The amount of shift calculated by the second table is sometimes called the "good suffix shift"[2] or "(strong) good suffix rule".</p>
<p>
    The original published Boyer-Moor algorithm [1] uses a simpler, weaker, version of the good suffix rule in which each entry in the above table did not require a mis-match for the left-most character. This is sometimes called the "weak good suffix rule" and is not sufficient for proving that Boyer-Moore runs in linear worst-case time.</p>
<p>
    <b>Performance of the Boyer-Moore string search algorithm</b></p>
<p>
    The worst-case to find all occurrences in a text needs approximately 3*N comparisons, hence the complexity is O(n), regardless whether the text contains a match or not. The proof is due to Richard Cole, see R. COLE, Tight bounds on the complexity of the Boyer-Moore algorithm, Proceedings of the 2nd Annual ACM-SIAM Symposium on Discrete Algorithms, (1991) for details. This proof took some years to determine. In the year the algorithm was devised, 1977, the maximum number of comparisons was shown to be no more than 6*N; in 1980 it was shown to be no more than 4*N, until Cole's result in 1991.</p>
<p>
    <b>References</b></p>
<p>
    1. ^ R. S. Boyer; J. S. Moore (1977). "A fast string searching algorithm". Comm. ACM 20: 762-772.</p>", 
            "inputSample": "GGCCTCATATCTCTCT
CCCATTGGCCTCATATCTCTCTCCCTCCCTCCCCTGCCCAGGCTGCTTGGCATGG", 
            "inputTip": "two lines and only characters “ACGT” in the string.
the first line is string (< = 102000)
the second line is text(< = 700000)", 
            "judgeModel": 0, 
            "level": 1, 
            "limitMemory": 65535, 
            "limitTime": 1000, 
            "outputSample": "6", 
            "outputTip": "position of the string in text
else -1", 
            "probId": 31, 
            "standardSource": "#include <stdio.h>
#include <string.h>
void Get_next(char *p, int *next)
{
    int i,j,slen;
    slen = strlen(p);
    i=0;
    next[0]=-1;
    j=-1;
    while (i < slen)
        if (j==-1 || p[i]==p[j])
        {
            ++i;
            ++j;
            next[i]=j;
        }
        else j=next[j];
}
int Index(char *s, char *t, int pos)
{
    int i,j,next[120],slen,tlen;
    slen = strlen(s);
    tlen = strlen(t);
    Get_next(t,next);
    i = pos;
    j = 0;
    while (i < slen && j < tlen)
        if (j == -1 || s[i] == t[j])
        {
            i++;
            j++;
        }
        else j = next[j];
        return i-tlen;
}

int main()
{
    char s[4500],t[120];
    int location;
    gets(t);
    gets(s);
    location = Index(s,t,0)+1;
    printf(\"%d\\n\",location);
    return 0;
}", 
            "testdataNum": null, 
            "title": "Boyer–Moore–Horspool algorithm", 
            "totalSubmit": 577
        }, 
        {
            "acedNum": 0, 
            "author": null, 
            "codeLimit": 0, 
            "createTime": "2012-09-01 09:37:15", 
            "description": "<p>
    长江游艇俱乐部在长江上设置了n 个游艇出租站1，2，…，n。游客可在这些游艇出租站租用游艇，并在下游的任何一个游艇出租站归还游艇。游艇出租站i 到游艇出租站j 之间的租金为r(i,j),1< =i< j < =n。试设计一个算法，计算出从游艇出租站1 到游艇出租站n 所需的最少租金。</p>", 
            "inputSample": "3
5 15
7", 
            "inputTip": "第1 行中有1 个正整数n（n<=200），表示有n个游艇出租站。接下来的n-1 行是r(i,j),1< =i< j < =n。", 
            "judgeModel": 0, 
            "level": 1, 
            "limitMemory": 65535, 
            "limitTime": 1000, 
            "outputSample": "12", 
            "outputTip": "从游艇出租站1 到游艇出租站n所需的最少租金", 
            "probId": 32, 
            "standardSource": "#include <stdio.h>
#include <string.h>
#define MAX_POINT 201  
int dis[MAX_POINT];
int n;
int map[MAX_POINT][MAX_POINT];  
int main()
{int i,j;
while(scanf(\"%d\",&n)!=EOF)
    {
        for(i=1;i<=n;i++)
            for(j=1;j<=n;j++)
                map[i][j]=0;
        for(i=1;i<=n;i++)
            for(j=i+1;j<=n;j++)
                scanf(\"%d\",&map[i][j]),map[j][i]=map[i][j];
        for(i=2;i<=n;i++)
            dis[i]=map[1][i];
        for(i=2;i<=n;i++)
            for(j=2;j<=n;j++)
                {
                    if(i==j) continue;
                    if(dis[j]>dis[i]+map[i][j])
                        dis[j]=dis[i]+map[i][j];
                }
        printf(\"%d\\n\",dis[n]);
    }
return 0;
}", 
            "testdataNum": null, 
            "title": "Renting Boats", 
            "totalSubmit": 287
        }, 
        {
            "acedNum": 0, 
            "author": null, 
            "codeLimit": 0, 
            "createTime": "2012-09-01 09:37:15", 
            "description": "<p>设有n 种不同面值的硬币，各硬币的面值存于数组T［1:n］中。现要用这些面值的硬币来找钱。可以使用的各种面值的硬币个数存于数组Coins［1:n］中。 对于给定的1≤n≤10，硬币面值数组T和可以使用的各种面值的硬币个数数组Coins，以及钱数m，0≤m≤20001，编程计算找钱m的最少硬币数。</p>", 
            "inputSample": "3
1 3
2 3
5 3
18", 
            "inputTip": "<p>第一行中只有1 个整数给出n的值,第2 行起每行2 个数，分别是T[j]和Coins[j]。最后1 行是要找的钱数m。</p>", 
            "judgeModel": 0, 
            "level": 1, 
            "limitMemory": 65535, 
            "limitTime": 1000, 
            "outputSample": "5", 
            "outputTip": "<p>最少硬币数,无解时输出-1</p>", 
            "probId": 33, 
            "standardSource": "#include \"stdio.h\"
#include \"iostream\"
using namespace std;
int money[50]={0},c[50]={0};
int want=0,have=0,i,j;
int m,n,sum,temp;
int main()
{   scanf(\"%d\",&n);
    for(i=1;i<n+1;i++)  scanf(\"%d%d\",&money[i],&c[i]);
    scanf(\"%d\",&m);have=m;
    for(i=1;i<=n;i++)
        for(j=i+1;j<=n;j++)
        {   if(money[j]<money[i])
            {  swap(money[j],money[i]);swap(c[j],c[i]); }
        }
    for(i=n;i>=1;i--)
    {    if(m>=money[i])
        {   if((m/money[i])>=c[i]) temp=c[i];
            else temp=m/money[i];
            sum=sum+temp;
            want=want+temp*money[i];        
            m=m-temp*money[i];
            continue;
        }   
    }
    if(want==have) printf(\"%d\",sum);
    else printf(\"%d\",-1);
    return 0;
}", 
            "testdataNum": null, 
            "title": "Coin Changing", 
            "totalSubmit": 427
        }, 
        {
            "acedNum": 0, 
            "author": null, 
            "codeLimit": 0, 
            "createTime": "2012-09-01 09:37:15", 
            "description": "<p>
    A chess rook can move horizontally o r vertically to any square in the same row o r in the same column of a chessboard. Find the number of shortest paths by which a rook can move from one corner of a chessboard to the diagonally opposite corner。</p>", 
            "inputSample": "4", 
            "inputTip": "a interger number n is row and column of chessboard. 0<= n<=16", 
            "judgeModel": 0, 
            "level": 0, 
            "limitMemory": 65535, 
            "limitTime": 1000, 
            "outputSample": "20", 
            "outputTip": "the number of shortest paths.", 
            "probId": 34, 
            "standardSource": "#include<stdio.h>
int main()
{
    int n;
    scanf(\"%d\",&n);
    long long f(int m,int n);
    printf(\"%lld\\n\",f(2*n-2,n-1));
    return 0;
}
long long f(int x,int y)
{
    long long d;
    if(y==0)d=1;
    else d=f(x,y-1)*(x-y+1)/y;
    return d;
}", 
            "testdataNum": null, 
            "title": "Shortest path counting", 
            "totalSubmit": 176
        }, 
        {
            "acedNum": 0, 
            "author": null, 
            "codeLimit": 0, 
            "createTime": "2012-09-01 09:37:15", 
            "description": "<p>
    设有n 个程序{1,2,…, n }要存放在长度为L的磁带上。程序i存放在磁带上的长度是l<sub>i</sub> ，1 < = i < = n。 程序存储问题要求确定这n 个程序在磁带上的一个存储方案，使得能够在磁带上存储尽可能多的程序。在保证存储最多程序的前提下还要求磁带的利用率达到最大。 对于给定的n个程序存放在磁带上的长度，编程计算磁带上最多可以存储的程序数和占用磁带的长度。</p>", 
            "inputSample": "9 50
2 3 13 8 80 20 21 22 23", 
            "inputTip": "第一行是2 个正整数，分别表示文件个数n <=600和磁带的长度L<=6000。接下来的1 行中，有n个正整数，表示程序存放在磁带上的长度。", 
            "judgeModel": 0, 
            "level": 1, 
            "limitMemory": 65535, 
            "limitTime": 1000, 
            "outputSample": "5 49
2 3 13 8 23", 
            "outputTip": "第1 行输出最多可以存储的程序数和占用磁带的长度；第2行输出存放在磁带上的每个程序的长度。", 
            "probId": 35, 
            "standardSource": "#include<iostream>
using namespace std;
int n; 
int c;
int *p;
int *w;
int *x;
int *best_x,best_w,best_p;
int a[10000][800]={0};
int b[10000][2]={0};
int mmm=1;
bool check(int i,int cw);
void tryLoad(int i,int cw,int cp);

int main()
{
    int i;
    cin>>n;
    w=new int[n+1];
    p=new int[n+1];
    x=new int[n+1];
    best_x=new int[n+1];
    best_w=0;
    best_p=0;
    
    cin>>c;
    for( i=1;i<=n;i++)
    {
        cin>>w[i];
        p[i]=1;
        best_x[i]=x[i]=0;
    }
    
    tryLoad(1,0,0);
    cout<<best_p<<\" \"<<best_w<<endl;
    for (i=1;i<=mmm;i++)
    {
        if (b[i][1]==best_w&&b[i][0]==best_p)
        {
            for (int u=1;u<=n;u++)
            {
                if (a[i][u]==1)
                {
                    cout<<w[u]<<\" \";
                }
                
            }
            cout<<endl;
            break;
        }
    }
    return 0;
}

bool check(int i,int cw)
{
    if(cw+x[i]*w[i]>c)
        return false;
    else
        return true;
}

void tryLoad(int i,int cw,int cp)
{int k;
    if(i>n)
    {
        for( k=1;k<=n;k++)
        {
            a[mmm][k]=x[k];
        }
        b[mmm][1]=cw;b[mmm][0]=cp;
        mmm++;
        if(cp>best_p||(cw>best_w&&cp>=best_p))
        {
            best_w=cw;
            best_p=cp;
        }
        
        for(k=1;k<=n;k++)
            best_x[k]=x[k];
    }
    else
        for(int j=1;j>=0;j--)
        {
            x[i]=j;
            if(check(i,cw))
            {
                cw+=x[i]*w[i];
                cp+=x[i]*p[i];
                tryLoad(i+1,cw,cp);
                cw-=x[i]*w[i];
                cp-=x[i]*p[i];
            }
        }
}", 
            "testdataNum": null, 
            "title": "Maximum Tape Utilization Ratio", 
            "totalSubmit": 408
        }, 
        {
            "acedNum": 0, 
            "author": null, 
            "codeLimit": 0, 
            "createTime": "2012-09-01 09:39:18", 
            "description": "<p>
    A binary search algorithm (or binary chop) is a technique for finding a particular value in a sorted list. It makes progressively better guesses, and closes in on the sought value, by comparing an element halfway with what has been determined to be an element too low in the list and one too high in the list.</p>
<p>
    A binary search finds the median element in a list, compares its value to the one you are searching for, and determines if it’s greater than, less than, or equal to the one you want.</p>
<p>
    A guess that turns out to be too high becomes the new top of the list, and one too low the new bottom of the list. The binary search's next guess is halfway between the new list's top and bottom. Pursuing this strategy iteratively, it narrows the search by a factor 2 each time, and finds your value. A binary search is an example of a divide and conquer algorithm (more specifically a decrease and conquer algorithm) and a dichotomic search (more at Search algorithm).</p>
<p>
    The most common application of binary search is to find a specific value in a sorted list. To cast this in the frame of the guessing game, realize that we are now guessing the index, or numbered place, of the value in the list. This is useful because, given the index, other data structures will contain associated information.</p>
<p>
    Suppose a data structure containing the classic collection of name, address, telephone number and so forth has been accumulated, and an array is prepared containing the names, numbered from one to N. A query might be: what is the telephone number for a given name X. To answer this the array would be searched and the index (if any) corresponding to that name determined, whereupon it would be used to report the associated telephone number and so forth. Appropriate provision must be made for the name not being in the list (typically by returning an index value of zero), indeed the question of interest might be only whether X is in the list or not.</p>
<p>
    If the list of names is in sorted order, a binary search will find a given name with far fewer probes than the simple procedure of probing each name in the list, one after the other in a linear search, and the procedure is much simpler than organising a hash table though that would be faster still, typically averaging just over one probe.</p>
<p>
    This applies for a uniform distribution of search items but if it is known that some few items are much more likely to be sought for than the majority then a linear search with the list ordered so that the most popular items are first may do better.</p>
<p>
    The binary search begins by comparing the sought value X to the value in the middle of the list; because the values are sorted, it is clear whether the sought value would belong before or after that middle value, and the search then continues through the correct half in the same way.</p>
<p>
    Only the sign of the difference is inspected: there is no attempt at an interpolation search based on the size of the differences. Your task is to write a program that, given a set numbers of ascending and a key, finding a particular postion in a sorted list.</p>
<p>
    Your task is simple, write a binary search program.</p>", 
            "inputSample": "10 7
0 1 2 3 4 5 6 7 8 9", 
            "inputTip": "The input contains one total numbers（N<=5000000） and a find key,followed by a line containing the integer numbers ascending sets.", 
            "judgeModel": 0, 
            "level": 0, 
            "limitMemory": 65535, 
            "limitTime": 5000, 
            "outputSample": "8", 
            "outputTip": "if find the key in the sorted list, output containing postion in a sorted list, else ouput -1.", 
            "probId": 36, 
            "standardSource": "main()
{int n,k;
scanf(\"%d%d\",&n,&k);
printf(\"%d\\n\",k+1);
    if(k>n)
        puts(\"-1\");
}", 
            "testdataNum": null, 
            "title": "Binary search", 
            "totalSubmit": 431
        }, 
        {
            "acedNum": 0, 
            "author": null, 
            "codeLimit": 0, 
            "createTime": "2012-09-01 09:39:19", 
            "description": "<p>
    俄式乘法，又被称为俄国农夫法，它是对两个正整数相乘的非主流算法。假设m和n是两个正整数，我们要计算它们的积。它的主要原理如下： if n is 偶数 n * m=n/2 * 2m else n * m=(n-1)/2 * 2m + m 该算法只包括折半，加倍，相加等几个简单操作，因此实现速度非常快。</p>", 
            "inputSample": "50  65", 
            "inputTip": "两个正整数 n,m。", 
            "judgeModel": 0, 
            "level": 0, 
            "limitMemory": 65535, 
            "limitTime": 1000, 
            "outputSample": "130 + 1040 + 2080 = 3250", 
            "outputTip": "n和m的乘积。
输出整个求和表达式，运算符与数字之间用一个空格隔开。", 
            "probId": 37, 
            "standardSource": "#include <iostream.h>
int main()
{
    unsigned long m,n,pro;
    cin>>n>>m;
    if(n%2==0)pro=n/2*(2*m);
    else pro=(n-1)/2*(2*m)+m;
    cout<<pro<<endl;
    return 0;
}", 
            "testdataNum": null, 
            "title": "俄式乘法", 
            "totalSubmit": 262
        }, 
        {
            "acedNum": 0, 
            "author": null, 
            "codeLimit": 0, 
            "createTime": "2012-09-01 09:40:28", 
            "description": "<p>
    Before ACM can do anything, a budget must be prepared and the necessary financial support obtained. The main income for this action comes from Irreversibly Bound Money (IBM). The idea behind is simple. Whenever some ACM member has any small money, he takes all the coins and throws them into a piggy-bank. You know that this process is irreversible, the coins cannot be removed without breaking the pig. After a sufficiently long time, there should be enough cash in the piggy-bank to pay everything that needs to be paid. But there is a big problem with piggy-banks. It is not possible to determine how much money is inside. So we might break the pig into pieces only to find out that there is not enough money. Clearly, we want to avoid this unpleasant situation. The only possibility is to weigh the piggy-bank and try to guess how many coins are inside. Assume that we are able to determine the weight of the pig exactly and that we know the weights of all coins of a given currency. Then there is some minimum amount of money in the piggy-bank that we can guarantee.</p>
<p>
    Your task is to find out this worst case and determine the minimum amount of cash inside the piggy-bank. We need your help. No more prematurely broken pigs!</p>", 
            "inputSample": "3
10 110
2
1 1
30 50
10 110
2
1 1
50 30
1 6
2
10 3
20 4", 
            "inputTip": "The input consists of T test cases. The number of them (T) is given on the first line of the input file. Each test case begins with a line containing two integers E and F. They indicate the weight of an empty pig and of the pig filled with coins. Both weights are given in grams. No pig will weigh more than 10 kg, that means 1 <= E <= F <= 10000. On the second line of each test case, there is an integer number N (1 <= N <= 500) that gives the number of various coins used in the given currency. Following this are exactly N lines, each specifying one coin type. These lines contain two integers each, Pand W (1 <= P <= 50000, 1 <= W <=10000). P is the value of the coin in monetary units, W is it's weight in grams.", 
            "judgeModel": 0, 
            "level": 2, 
            "limitMemory": 65535, 
            "limitTime": 1000, 
            "outputSample": "The minimum amount of money in the piggy-bank is 60.
The minimum amount of money in the piggy-bank is 100.
This is impossible.", 
            "outputTip": "Print exactly one line of output for each test case. The line must contain the sentence \"The minimum amount of money in the piggy-bank is X.\" where X is the minimum amount of money that can be achieved using coins with the given total weight. If the weight cannot be reached exactly, print a line \"This is impossible.\".", 
            "probId": 38, 
            "standardSource": "#include <stdio.h>
#include <memory.h>
#include <algorithm>
#define INF 0x3fffffff
#define MIN(x,y) ((x)<(y)?(x):(y))
using namespace std;

int coins[510][2];
int f[10100];
void init()
{
    int i;
    for(i=0;i<10100;++i)
        f[i] = INF;
}

int main()
{
    int T;
    scanf(\"%d\",&T);
    while(T--)
    {
        int E,F,m,n;
        init();
        scanf(\"%d%d\",&E,&F);
        m = F - E;
        scanf(\"%d\",&n);
        int i,j;
        for(i=1;i<=n;++i)   scanf(\"%d%d\",&coins[i][0],&coins[i][1]);
        f[m] = 0;
        for(i=1;i<=n;++i)   
            for(j=m;j>=0;--j)   
                if(j+coins[i][1] <= m) 
                    f[j] = MIN(f[j],f[j+coins[i][1]] + coins[i][0]);
        if(f[0] == INF) puts(\"This is impossible.\");
        else    printf(\"The minimum amount of money in the piggy-bank is %d.\\n\",f[0]);
    }
    return 0;
}", 
            "testdataNum": null, 
            "title": "Piggy-Bank", 
            "totalSubmit": 162
        }, 
        {
            "acedNum": 0, 
            "author": null, 
            "codeLimit": 0, 
            "createTime": "2012-09-01 09:40:28", 
            "description": "<p>
    n the game of Jack Straws, a number of plastic or wooden "straws" are dumped on the table and players try to remove them one-by-one without disturbing the other straws. Here, we are only concerned with if various pairs of straws are connected by a path of touching straws. You will be given a list of the endpoints for some straws (as if they were dumped on a large piece of graph paper) and then will be asked if various pairs of straws are connected. Note that touching is connecting, but also two straws can be connected indirectly via other connected straws.</p>", 
            "inputSample": "7
1 6 3 3 
4 6 4 9 
4 5 6 7 
1 4 3 5 
3 5 5 5 
5 2 6 3 
5 4 7 2 
1 4 
1 6 
3 3 
6 7 
2 3 
1 3 
0 0", 
            "inputTip": "A problem consists of multiple lines of input. The first line will be an integer n (1 < n < 13) giving the number of straws on the table. Each of the next n lines contain 4 positive integers, x1 , y1 , x2 and y2 , giving the coordinates, (x1 ; y1 ); (x2 ; y2 ) of the endpoints of a single straw. All coordinates will be less than 100. (Note that the straws will be of varying lengths.) The first straw entered will be known as straw #1, the second as straw #2, and so on. The remaining lines of input (except for the final line) will each contain two positive integers, a and b, both between 1 and n, inclusive. You are to determine if straw a can be connected to straw b. When a = 0 = b, the input is terminated. There will be no illegal input and there are no zero-length straws.", 
            "judgeModel": 0, 
            "level": 2, 
            "limitMemory": 65535, 
            "limitTime": 1000, 
            "outputSample": "CONNECTED 
NOT CONNECTED 
CONNECTED 
CONNECTED 
NOT CONNECTED 
CONNECTED", 
            "outputTip": "You should generate a line of output for each line containing a pair a and b, except the final line where a = 0 = b. The line should say simply \"CONNECTED\", if straw a is connected to straw b, or \"NOT CONNECTED\", if straw a is not connected to straw b. For our purposes, a straw is considered connected to itself.", 
            "probId": 39, 
            "standardSource": "#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define MAXSIZE 13

int rank[MAXSIZE];   

int parent[MAXSIZE]; 

int FindSet(int x){

    if( x != parent[x] ) parent[x] = FindSet(parent[x]);

     return parent[x];

}

void Union(int root1, int root2){

     int x = FindSet(root1), y = FindSet(root2);

     if( x == y ) return ;

     if( rank[x] > rank[y] ) parent[y] = x;

     else{

         parent[x] = y;

         if( rank[x] == rank[y] ) ++rank[y];

     }

}

void Initi(void){
     int i;
     memset(rank, 0, sizeof(rank));

     for(  i=0; i < MAXSIZE; ++i ) parent[i] = i;

}


struct point
{
    int x;
    int y;
};
typedef struct point point;
struct v{
    struct point start;
    struct point end;
};
typedef struct v v;
struct v seg[13];
int crossProduct(point * v1, point* v2){

    return v1->x*v2->y-v2->x*v1->y;
}

int direction(point* pi, point* pj, point* pk){
     point p1, p2;

     p1.x = pk->x - pi->x;
     p1.y = pk->y - pi->y;

     p2.x = pj->x - pi->x;
     p2.y = pj->y - pi->y;

    return crossProduct(&p1, &p2);
}

int onSegment(point* pi, point* pj, point* pk){
    int minx, miny, maxx, maxy;
    if (pi->x > pj->x){
         minx = pj->x;
         maxx = pi->x;
     }
    else{
         minx = pi->x;
         maxx = pj->x;
     }

    if (pi->y > pj->y){
         miny = pj->y;
         maxy = pi->y;
     }
    else{
         miny = pi->y;
         maxy = pj->y;
     }

    if (minx <= pk->x && pk->x <= maxx && miny <= pk->y && pk->y <= maxy)
        return 1;
    else
        return 0;
}

int segmentIntersect(point* p1, point* p2, point* p3, point* p4){
    int d1 = direction(p3, p4, p1);
    int d2 = direction(p3, p4, p2);
    int d3 = direction(p1, p2, p3);
    int d4 = direction(p1, p2, p4);
    if (d1 * d2 < 0 && d3 * d4 < 0)
        return 1;
    else if (!d1 && onSegment(p3, p4, p1))
        return 1;
    else if (!d2 && onSegment(p3, p4, p2))
        return 1;
    else if (!d3 && onSegment(p1, p2, p3))
        return 1;
    else if (!d4 && onSegment(p1, p2, p4))
        return 1;
    else
        return 0;
}

int main()
{
  int n,a,b,c,d,i,j;
  while(scanf(\"%d\",&n)==1&&n)
  {
    for(i=0;i<n;i++)
     { scanf(\"%d%d%d%d\",&a,&b,&c,&d);
       seg[i].start.x=a;
       seg[i].start.y=b;
       seg[i].end.x=c;
       seg[i].end.y=d;
     }
     Initi();
     for(i=0;i<n;i++)
      for(j=i+1;j<n;j++)
      {
         a=segmentIntersect(&seg[i].start,&seg[i].end,&seg[j].start,&seg[j].end);
          if(a)
          Union(i,j);

      }
     while(scanf(\"%d%d\",&a,&b)==2)
     {
         if(a==0&&b==0)
           break;
         if(FindSet(a-1)==FindSet(b-1))
          printf(\"CONNECTED\\n\");
        else
         printf(\"NOT CONNECTED\\n\");
     }
  }
  return 0;
}", 
            "testdataNum": null, 
            "title": "Jack Straws", 
            "totalSubmit": 182
        }
    ]
}